/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ChangeDetectionStrategy, Component, HostBinding, Input } from '@angular/core';
import { SliderComponent } from '../slider/slider.component';
import { ViewStrategy } from '../view-strategies/view-strategy';
import { ViewComponent } from '../view/view.component';
export class GridComponent {
    /**
     * @param {?} slider
     * @param {?} parentView
     * @param {?} viewStrategy
     */
    constructor(slider, parentView, viewStrategy) {
        this.slider = slider;
        this.parentView = parentView;
        this.viewStrategy = viewStrategy;
        this.itemLabels = [];
        this._hostClass = 'skm-datepicker-content';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('itemLabels' in changes) {
            this.itemLabels = this.itemLabels || [];
        }
    }
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    makeItemClasses(index, pane) {
        return [
            this.viewStrategy.itemClass,
            'skm-datepicker-item',
            (pane.values[index] === this.currentTimestamp) ? 'skm-datepicker-current' : '',
            (pane.values[index] === this.selectedTimestamp) ? 'skm-datepicker-selected' : '',
        ].join(' ');
    }
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    isDisabled(index, pane) {
        return (pane.values[index] < this.minTimestamp) || (pane.values[index] > this.maxTimestamp);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    trackIndex(index) {
        return index;
    }
}
GridComponent.decorators = [
    { type: Component, args: [{
                selector: 'skm-grid',
                template: `<div class="skm-datepicker-grid" (click)="parentView.selectItem($event, pane, slider.notPanning)">
  <div class="skm-datepicker-indent" [style.width.%]="100 / 7 * pane.indent"></div>
  <div *ngFor="let value of pane.values; trackBy: trackIndex; let i = index" class="skm-datepicker-cell">
    <button type="button" [attr.data-index]="i" [class]="makeItemClasses(i, pane)" [disabled]="isDisabled(i, pane)">
      {{itemLabels[i] || (value | date:itemFormat)}}
    </button>
  </div>
</div>
`,
                styles: [`button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
GridComponent.ctorParameters = () => [
    { type: SliderComponent, },
    { type: ViewComponent, },
    { type: ViewStrategy, },
];
GridComponent.propDecorators = {
    "pane": [{ type: Input },],
    "currentTimestamp": [{ type: Input },],
    "selectedTimestamp": [{ type: Input },],
    "minTimestamp": [{ type: Input },],
    "maxTimestamp": [{ type: Input },],
    "itemFormat": [{ type: Input },],
    "itemLabels": [{ type: Input },],
    "_hostClass": [{ type: HostBinding, args: ['class',] },],
};
function GridComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GridComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GridComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    GridComponent.propDecorators;
    /** @type {?} */
    GridComponent.prototype.pane;
    /** @type {?} */
    GridComponent.prototype.currentTimestamp;
    /** @type {?} */
    GridComponent.prototype.selectedTimestamp;
    /** @type {?} */
    GridComponent.prototype.minTimestamp;
    /** @type {?} */
    GridComponent.prototype.maxTimestamp;
    /** @type {?} */
    GridComponent.prototype.itemFormat;
    /** @type {?} */
    GridComponent.prototype.itemLabels;
    /** @type {?} */
    GridComponent.prototype._hostClass;
    /** @type {?} */
    GridComponent.prototype.slider;
    /** @type {?} */
    GridComponent.prototype.parentView;
    /** @type {?} */
    GridComponent.prototype.viewStrategy;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZC9ncmlkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUE0QixNQUFNLGVBQWUsQ0FBQztBQUVqSCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQWdCdkQsTUFBTTs7Ozs7O0lBYUosWUFBcUIsTUFBdUIsRUFDdkIsVUFBeUIsRUFDakI7UUFGUixXQUFNLEdBQU4sTUFBTSxDQUFpQjtRQUN2QixlQUFVLEdBQVYsVUFBVSxDQUFlO1FBQ2pCLGlCQUFZLEdBQVosWUFBWTswQkFOVCxFQUFFOzBCQUVVLHdCQUF3QjtLQUtuRTs7Ozs7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztTQUN6QztLQUNGOzs7Ozs7SUFFRCxlQUFlLENBQUMsS0FBYSxFQUFFLElBQVU7UUFDdkMsTUFBTSxDQUFDO1lBQ0wsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTO1lBQzNCLHFCQUFxQjtZQUNyQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQzlFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLEVBQUU7U0FDakYsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDYjs7Ozs7O0lBRUQsVUFBVSxDQUFDLEtBQWEsRUFBRSxJQUFVO1FBQ2xDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDN0Y7Ozs7O0lBRUQsVUFBVSxDQUFDLEtBQWE7UUFDdEIsTUFBTSxDQUFDLEtBQUssQ0FBQztLQUNkOzs7WUFyREYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxVQUFVO2dCQUNwQixRQUFRLEVBQUU7Ozs7Ozs7O0NBUVg7Z0JBQ0MsTUFBTSxFQUFFLENBQUMsazFCQUFrMUIsQ0FBQztnQkFDNTFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2FBQ2hEOzs7O1lBakJRLGVBQWU7WUFFZixhQUFhO1lBRGIsWUFBWTs7O3FCQWtCbEIsS0FBSztpQ0FFTCxLQUFLO2tDQUNMLEtBQUs7NkJBQ0wsS0FBSzs2QkFDTCxLQUFLOzJCQUVMLEtBQUs7MkJBQ0wsS0FBSzsyQkFFTCxXQUFXLFNBQUMsT0FBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi9wYW5lJztcclxuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vc2xpZGVyL3NsaWRlci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuLi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneSc7XHJcbmltcG9ydCB7IFZpZXdDb21wb25lbnQgfSBmcm9tICcuLi92aWV3L3ZpZXcuY29tcG9uZW50JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnc2ttLWdyaWQnLFxyXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLWdyaWRcIiAoY2xpY2spPVwicGFyZW50Vmlldy5zZWxlY3RJdGVtKCRldmVudCwgcGFuZSwgc2xpZGVyLm5vdFBhbm5pbmcpXCI+XHJcbiAgPGRpdiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLWluZGVudFwiIFtzdHlsZS53aWR0aC4lXT1cIjEwMCAvIDcgKiBwYW5lLmluZGVudFwiPjwvZGl2PlxyXG4gIDxkaXYgKm5nRm9yPVwibGV0IHZhbHVlIG9mIHBhbmUudmFsdWVzOyB0cmFja0J5OiB0cmFja0luZGV4OyBsZXQgaSA9IGluZGV4XCIgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1jZWxsXCI+XHJcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBbYXR0ci5kYXRhLWluZGV4XT1cImlcIiBbY2xhc3NdPVwibWFrZUl0ZW1DbGFzc2VzKGksIHBhbmUpXCIgW2Rpc2FibGVkXT1cImlzRGlzYWJsZWQoaSwgcGFuZSlcIj5cclxuICAgICAge3tpdGVtTGFiZWxzW2ldIHx8ICh2YWx1ZSB8IGRhdGU6aXRlbUZvcm1hdCl9fVxyXG4gICAgPC9idXR0b24+XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2BidXR0b257ZGlzcGxheTpibG9jaztjb2xvcjppbmhlcml0fWJ1dHRvbjpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9YnV0dG9uW2Rpc2FibGVkXXtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1wYW5le2ZsZXgtc2hyaW5rOjA7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO292ZXJmbG93OmhpZGRlbn0uc2ttLWRhdGVwaWNrZXItd2Vla3tkaXNwbGF5OmZsZXh9LnNrbS1kYXRlcGlja2VyLXdlZWtkYXl7d2lkdGg6MTQuMjg1NzElfS5za20tZGF0ZXBpY2tlci1jb250ZW50e2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uc2ttLWRhdGVwaWNrZXItZ3JpZHtmbGV4OjEgMCAwO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcDthbGlnbi1jb250ZW50OmZsZXgtc3RhcnQ7cG9pbnRlci1ldmVudHM6bm9uZX0uc2ttLWRhdGVwaWNrZXItaW5kZW50e2hlaWdodDoxNi42NjY2NyV9LnNrbS1kYXRlcGlja2VyLWNlbGx7ZGlzcGxheTpmbGV4fTpob3N0LWNvbnRleHQoLnNrbS1kYXRlcGlja2VyLWRheXMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MTQuMjg1NzElO2hlaWdodDoxNi42NjY2NyV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItbW9udGhzLXZpZXcpIC5za20tZGF0ZXBpY2tlci1jZWxse3dpZHRoOjMzLjMzMzMzJTtoZWlnaHQ6MjUlfTpob3N0LWNvbnRleHQoLnNrbS1kYXRlcGlja2VyLXllYXJzLXZpZXcpIC5za20tZGF0ZXBpY2tlci1jZWxse3dpZHRoOjIwJTtoZWlnaHQ6MjUlfS5za20tZGF0ZXBpY2tlci1pdGVte2ZsZXg6MTtwb2ludGVyLWV2ZW50czphdXRvfWBdLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgR3JpZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgQElucHV0KCkgcGFuZTogUGFuZTtcclxuXHJcbiAgQElucHV0KCkgY3VycmVudFRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIHNlbGVjdGVkVGltZXN0YW1wOiBudW1iZXI7XHJcbiAgQElucHV0KCkgbWluVGltZXN0YW1wOiBudW1iZXI7XHJcbiAgQElucHV0KCkgbWF4VGltZXN0YW1wOiBudW1iZXI7XHJcblxyXG4gIEBJbnB1dCgpIGl0ZW1Gb3JtYXQ6IHN0cmluZztcclxuICBASW5wdXQoKSBpdGVtTGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcmVhZG9ubHkgX2hvc3RDbGFzcyA9ICdza20tZGF0ZXBpY2tlci1jb250ZW50JztcclxuXHJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgc2xpZGVyOiBTbGlkZXJDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgcmVhZG9ubHkgcGFyZW50VmlldzogVmlld0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXdTdHJhdGVneTogVmlld1N0cmF0ZWd5KSB7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICBpZiAoJ2l0ZW1MYWJlbHMnIGluIGNoYW5nZXMpIHtcclxuICAgICAgdGhpcy5pdGVtTGFiZWxzID0gdGhpcy5pdGVtTGFiZWxzIHx8IFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbWFrZUl0ZW1DbGFzc2VzKGluZGV4OiBudW1iZXIsIHBhbmU6IFBhbmUpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgdGhpcy52aWV3U3RyYXRlZ3kuaXRlbUNsYXNzLFxyXG4gICAgICAnc2ttLWRhdGVwaWNrZXItaXRlbScsXHJcbiAgICAgIChwYW5lLnZhbHVlc1tpbmRleF0gPT09IHRoaXMuY3VycmVudFRpbWVzdGFtcCkgPyAnc2ttLWRhdGVwaWNrZXItY3VycmVudCcgOiAnJyxcclxuICAgICAgKHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkgPyAnc2ttLWRhdGVwaWNrZXItc2VsZWN0ZWQnIDogJycsXHJcbiAgICBdLmpvaW4oJyAnKTtcclxuICB9XHJcblxyXG4gIGlzRGlzYWJsZWQoaW5kZXg6IG51bWJlciwgcGFuZTogUGFuZSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChwYW5lLnZhbHVlc1tpbmRleF0gPCB0aGlzLm1pblRpbWVzdGFtcCkgfHwgKHBhbmUudmFsdWVzW2luZGV4XSA+IHRoaXMubWF4VGltZXN0YW1wKTtcclxuICB9XHJcblxyXG4gIHRyYWNrSW5kZXgoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=