/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive } from '@angular/core';
import { ViewStrategy } from './view-strategy';
import { ViewMode } from '../datepicker/view-mode';
import { startOfMonth } from '../util/helpers';
var DaysStrategyDirective = /** @class */ (function (_super) {
    tslib_1.__extends(DaysStrategyDirective, _super);
    function DaysStrategyDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.viewMode = ViewMode.Days;
        _this.itemClass = 'skm-datepicker-day';
        return _this;
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    DaysStrategyDirective.prototype.normalizeTimestamp = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return timestamp;
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    DaysStrategyDirective.prototype.makeInitPanesSeed = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return startOfMonth(timestamp).valueOf();
    };
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    DaysStrategyDirective.prototype.makePane = /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    function (timestamp, add, baseOrder, weekStart) {
        var /** @type {?} */ date = new Date(timestamp);
        date.setMonth(add + date.getMonth());
        var /** @type {?} */ firstDay = date.getDay();
        date.setMonth(1 + date.getMonth());
        date.setDate(0);
        var /** @type {?} */ monthLength = date.getDate();
        var /** @type {?} */ values = [];
        for (var /** @type {?} */ i = 1; i <= monthLength; i++) {
            values.push(date.setDate(i));
        }
        return {
            order: baseOrder + add,
            values: values,
            indent: (firstDay - weekStart + 7) % 7 || 7,
        };
    };
    DaysStrategyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[skmDaysStrategy]',
                    providers: [
                        { provide: ViewStrategy, useExisting: DaysStrategyDirective },
                    ],
                },] },
    ];
    return DaysStrategyDirective;
}(ViewStrategy));
export { DaysStrategyDirective };
function DaysStrategyDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    DaysStrategyDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    DaysStrategyDirective.ctorParameters;
    /** @type {?} */
    DaysStrategyDirective.prototype.viewMode;
    /** @type {?} */
    DaysStrategyDirective.prototype.itemClass;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5cy1zdHJhdGVneS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMxQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBR25ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7SUFRSixpREFBWTs7O3lCQUNqQyxRQUFRLENBQUMsSUFBSTswQkFDWixvQkFBb0I7Ozs7Ozs7SUFFekMsa0RBQWtCOzs7O0lBQWxCLFVBQW1CLFNBQWlCO1FBQ2xDLE1BQU0sQ0FBQyxTQUFTLENBQUM7S0FDbEI7Ozs7O0lBRUQsaURBQWlCOzs7O0lBQWpCLFVBQWtCLFNBQWlCO1FBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDMUM7Ozs7Ozs7O0lBRUQsd0NBQVE7Ozs7Ozs7SUFBUixVQUFTLFNBQWlCLEVBQUUsR0FBVyxFQUFFLFNBQWlCLEVBQUUsU0FBa0I7UUFDNUUscUJBQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLHFCQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQixxQkFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRW5DLHFCQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDbEIsR0FBRyxDQUFDLENBQUMscUJBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUI7UUFFRCxNQUFNLENBQUM7WUFDTCxLQUFLLEVBQUUsU0FBUyxHQUFHLEdBQUc7WUFDdEIsTUFBTSxFQUFFLE1BQU07WUFDZCxNQUFNLEVBQUUsQ0FBQyxRQUFRLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO1NBQzVDLENBQUM7S0FDSDs7Z0JBckNGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsbUJBQW1CO29CQUM3QixTQUFTLEVBQUU7d0JBQ1QsRUFBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxxQkFBcUIsRUFBQztxQkFDNUQ7aUJBQ0Y7O2dDQVpEO0VBYTJDLFlBQVk7U0FBMUMscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFZpZXdTdHJhdGVneSB9IGZyb20gJy4vdmlldy1zdHJhdGVneSc7XHJcbmltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBzdGFydE9mTW9udGggfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbc2ttRGF5c1N0cmF0ZWd5XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogVmlld1N0cmF0ZWd5LCB1c2VFeGlzdGluZzogRGF5c1N0cmF0ZWd5RGlyZWN0aXZlfSxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF5c1N0cmF0ZWd5RGlyZWN0aXZlIGV4dGVuZHMgVmlld1N0cmF0ZWd5IHtcclxuICByZWFkb25seSB2aWV3TW9kZSA9IFZpZXdNb2RlLkRheXM7XHJcbiAgcmVhZG9ubHkgaXRlbUNsYXNzID0gJ3NrbS1kYXRlcGlja2VyLWRheSc7XHJcblxyXG4gIG5vcm1hbGl6ZVRpbWVzdGFtcCh0aW1lc3RhbXA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGltZXN0YW1wO1xyXG4gIH1cclxuXHJcbiAgbWFrZUluaXRQYW5lc1NlZWQodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHN0YXJ0T2ZNb250aCh0aW1lc3RhbXApLnZhbHVlT2YoKTtcclxuICB9XHJcblxyXG4gIG1ha2VQYW5lKHRpbWVzdGFtcDogbnVtYmVyLCBhZGQ6IG51bWJlciwgYmFzZU9yZGVyOiBudW1iZXIsIHdlZWtTdGFydDogV2Vla0RheSk6IFBhbmUge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcbiAgICBkYXRlLnNldE1vbnRoKGFkZCArIGRhdGUuZ2V0TW9udGgoKSk7XHJcbiAgICBjb25zdCBmaXJzdERheSA9IGRhdGUuZ2V0RGF5KCk7XHJcblxyXG4gICAgZGF0ZS5zZXRNb250aCgxICsgZGF0ZS5nZXRNb250aCgpKTtcclxuICAgIGRhdGUuc2V0RGF0ZSgwKTtcclxuICAgIGNvbnN0IG1vbnRoTGVuZ3RoID0gZGF0ZS5nZXREYXRlKCk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBtb250aExlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKGRhdGUuc2V0RGF0ZShpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JkZXI6IGJhc2VPcmRlciArIGFkZCxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICAgIGluZGVudDogKGZpcnN0RGF5IC0gd2Vla1N0YXJ0ICsgNykgJSA3IHx8IDcsIC8vIERlZmF1bHRpbmcgdG8gZnVsbCB3ZWVrIG1ha2VzIGZvciBtb3JlIGEgYmFsYW5jZWQgY2VsbHMgbGF5b3V0XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuIl19