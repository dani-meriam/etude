(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/animations'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('skimmed-datepicker', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@angular/animations', 'rxjs', 'rxjs/operators'], factory) :
    (factory((global['skimmed-datepicker'] = {}),global.ng.core,global.ng.common,global.ng.forms,global.ng.animations,global.rxjs,global.rxjs.operators));
}(this, (function (exports,core,common,forms,animations,rxjs,operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} date
     * @return {?}
     */
    function isValidDate(date) {
        return !isNaN(date.getTime());
    }
    /**
     * @param {?} date
     * @return {?}
     */
    function startOfDay(date) {
        var /** @type {?} */ d = new Date(/** @type {?} */ (date));
        d.setHours(0, 0, 0, 0);
        return d;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    function startOfMonth(date) {
        var /** @type {?} */ d = new Date(/** @type {?} */ (date));
        d.setHours(0, 0, 0, 0);
        d.setDate(1);
        return d;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    function startOfYear(date) {
        var /** @type {?} */ d = new Date(/** @type {?} */ (date));
        d.setHours(0, 0, 0, 0);
        d.setMonth(0, 1);
        return d;
    }
    /**
     * @param {?} panRatio
     * @return {?}
     */
    function createEaseOut(panRatio) {
        var /** @type {?} */ a = (panRatio - 2) / Math.pow(panRatio, 3);
        var /** @type {?} */ b = (3 - 2 * panRatio) / Math.pow(panRatio, 2);
        return function easeOut(x) {
            return (x >= panRatio) ? 1 : ((a * x + b) * x + 1) * x;
        };
    }
    /**
     * @return {?}
     */
    function noop() {
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {string} */
    var ViewMode = {
        Days: 'days',
        Months: 'months',
        Years: 'years',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DatepickerComponent = (function () {
        function DatepickerComponent(cd, locale) {
            this.cd = cd;
            this.locale = locale;
            this.dateChange = new core.EventEmitter();
            this.dayFormat = 'd';
            this.monthFormat = 'MMM';
            this.yearFormat = 'y';
            this.headingFormat = 'MMMM y';
            this.weekStart = common.WeekDay.Monday;
            this.view = ViewMode.Days;
            this.ViewMode = ViewMode;
            this.onChange = noop;
            this.onTouched = noop;
        }
        Object.defineProperty(DatepickerComponent.prototype, "date", {
            set: /**
             * @param {?} dirtyDate
             * @return {?}
             */ function (dirtyDate) {
                if (dirtyDate == null) {
                    this.selectedTimestamp = undefined;
                    return;
                }
                var /** @type {?} */ date = startOfDay(dirtyDate);
                if (date.getTime() !== this.selectedTimestamp) {
                    this.selectedTimestamp = isValidDate(date) ? date.getTime() : undefined;
                    if (typeof this.selectedTimestamp !== 'undefined') {
                        this.initialTimestamp = this.selectedTimestamp;
                        this.view = ViewMode.Days;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatepickerComponent.prototype, "min", {
            set: /**
             * @param {?} dirtyDate
             * @return {?}
             */ function (dirtyDate) {
                var /** @type {?} */ date = startOfDay(dirtyDate);
                this.minTimestamp = isValidDate(date) ? date.valueOf() : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatepickerComponent.prototype, "max", {
            set: /**
             * @param {?} dirtyDate
             * @return {?}
             */ function (dirtyDate) {
                var /** @type {?} */ date = startOfDay(dirtyDate);
                this.maxTimestamp = isValidDate(date) ? date.valueOf() : undefined;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        DatepickerComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if ('weekDayLabels' in changes) {
                    this.weekDayLabels = this.weekDayLabels || common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Abbreviated);
                }
            };
        /**
         * @return {?}
         */
        DatepickerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.currentTimestamp = startOfDay(new Date()).getTime();
                this.initialTimestamp = this.selectedTimestamp || this.currentTimestamp;
                this.weekDayLabels = this.weekDayLabels || common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Abbreviated);
            };
        /**
         * @param {?} timestamp
         * @return {?}
         */
        DatepickerComponent.prototype.selectDay = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                console.log(timestamp);
                this.selectedTimestamp = timestamp;
                var /** @type {?} */ date = (typeof timestamp !== 'undefined') ? new Date(timestamp) : undefined;
                this.onChange(date);
                this.dateChange.emit(date);
            };
        /**
         * @param {?} timestamp
         * @param {?} view
         * @param {?} direction
         * @return {?}
         */
        DatepickerComponent.prototype.switchView = /**
         * @param {?} timestamp
         * @param {?} view
         * @param {?} direction
         * @return {?}
         */
            function (timestamp, view, direction) {
                var _this = this;
                this.zoomDirection = direction;
                setTimeout(function () {
                    _this.initialTimestamp = timestamp;
                    _this.view = view;
                    _this.cd.markForCheck();
                });
            };
        // ControlValueAccessor implementation
        /**
         * @param {?} obj
         * @return {?}
         */
        DatepickerComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                this.date = obj;
                this.cd.markForCheck();
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        DatepickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        DatepickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouched = fn;
                // TODO implement
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        DatepickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                // TODO implement
                this.cd.markForCheck();
            };
        DatepickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'skm-datepicker',
                        template: "<div class=\"skm-datepicker\" [ngSwitch]=\"view\">\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Days\"\n    skmDaysStrategy\n    class=\"skm-datepicker-view skm-datepicker-days-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [deselectEnabled]=\"deselectEnabled\"\n\n    [headingFormat]=\"headingFormat\"\n    [weekStart]=\"weekStart\"\n    [weekDayLabels]=\"weekDayLabels\"\n    [itemFormat]=\"dayFormat\"\n    [itemLabels]=\"dayLabels\"\n\n    (headerClick)=\"switchView($event, ViewMode.Months, 'out')\"\n    (itemChange)=\"selectDay($event)\"\n  ></skm-view>\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Months\"\n    skmMonthsStrategy\n    class=\"skm-datepicker-view skm-datepicker-months-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [headingFormat]=\"yearFormat\"\n    [itemFormat]=\"monthFormat\"\n    [itemLabels]=\"monthLabels\"\n\n    (headerClick)=\"switchView($event, ViewMode.Years, 'out')\"\n    (itemChange)=\"switchView($event, ViewMode.Days, 'in')\"\n  ></skm-view>\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Years\"\n    skmYearsStrategy\n    class=\"skm-datepicker-view skm-datepicker-years-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [headingFormat]=\"yearFormat\"\n    [itemFormat]=\"yearFormat\"\n\n    (itemChange)=\"switchView($event, ViewMode.Months, 'in')\"\n  ></skm-view>\n</div>\n",
                        styles: [".skm-datepicker{position:relative;overflow:hidden}.skm-datepicker-view{display:block;position:absolute;height:100%;width:100%}", "button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            { provide: forms.NG_VALUE_ACCESSOR, useExisting: DatepickerComponent, multi: true },
                        ],
                    },] },
        ];
        /** @nocollapse */
        DatepickerComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef, },
                { type: undefined, decorators: [{ type: core.Inject, args: [core.LOCALE_ID,] },] },
            ];
        };
        DatepickerComponent.propDecorators = {
            "date": [{ type: core.Input },],
            "dateChange": [{ type: core.Output },],
            "min": [{ type: core.Input },],
            "max": [{ type: core.Input },],
            "deselectEnabled": [{ type: core.Input },],
            "dayFormat": [{ type: core.Input },],
            "monthFormat": [{ type: core.Input },],
            "yearFormat": [{ type: core.Input },],
            "headingFormat": [{ type: core.Input },],
            "weekStart": [{ type: core.Input },],
            "dayLabels": [{ type: core.Input },],
            "weekDayLabels": [{ type: core.Input },],
            "monthLabels": [{ type: core.Input },],
            "view": [{ type: core.Input },],
        };
        return DatepickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?=} timing
     * @return {?}
     */
    function slide(timing) {
        if (timing === void 0) {
            timing = 150;
        }
        return animations.trigger('slide', [
            animations.state('panning', animations.style({
                transform: 'translateX({{x}}%)',
            }), { params: { x: 0 } }),
            animations.transition('* => 1', animations.animate(timing, animations.style({
                transform: 'translateX(-100%)',
            }))),
            animations.transition('* => -1', animations.animate(timing, animations.style({
                transform: 'translateX(100%)',
            }))),
            animations.transition('panning => idle', animations.animate(timing)),
        ]);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderComponent = (function () {
        function SliderComponent(hostRef, cd, zone) {
            this.hostRef = hostRef;
            this.cd = cd;
            this.zone = zone;
            this.prevDisabled = false;
            this.nextDisabled = false;
            this.slideDone = new core.EventEmitter();
            this.notPanning = true;
            this.wrapperWidth = 1;
            this.panOffset = 0;
            this.ngUnsubscribe$ = new rxjs.Subject();
            this.easeOut = createEaseOut(1.3);
            this.cd.detach();
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        SliderComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.changeSlideTrigger();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.zone.runOutsideAngular(function () {
                    var /** @type {?} */ host = _this.hostRef.nativeElement;
                    rxjs.fromEvent(host, 'mousedown').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.startPress(); });
                    if ('Hammer' in window) {
                        var /** @type {?} */ hammer = new Hammer(host);
                        rxjs.fromEvent(hammer, 'panstart').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.startPan(); });
                        rxjs.fromEvent(hammer, 'panmove').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function (e) { return _this.pan(e); });
                        rxjs.fromEvent(hammer, 'panend pancancel').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.endPan(); });
                        rxjs.fromEvent(hammer, 'swiperight').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.swipe(-1); });
                        rxjs.fromEvent(hammer, 'swipeleft').pipe(operators.takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.swipe(1); });
                    }
                });
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.ngUnsubscribe$.next();
                this.ngUnsubscribe$.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.done = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === this.lastDoneEventToState) {
                    // workaround for https://github.com/angular/angular/issues/24084
                    return;
                }
                this.lastDoneEventToState = event.toState;
                if ((typeof event.toState) === 'number') {
                    this.slideDone.emit(/** @type {?} */ (event.toState));
                }
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        SliderComponent.prototype.slide = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                var _this = this;
                this.changeSlideTrigger();
                setTimeout(function () { return _this.changeSlideTrigger(/** @type {?} */ (direction)); });
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.startPress = /**
         * @return {?}
         */
            function () {
                this.notPanning = true;
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.startPan = /**
         * @return {?}
         */
            function () {
                this.notPanning = false;
                this.wrapperWidth = this.hostRef.nativeElement.offsetWidth;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.pan = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ multiplier = (event.deltaX > 0 && this.prevDisabled || event.deltaX < 0 && this.nextDisabled) ? 0.1 : 1;
                var /** @type {?} */ absOffset = Math.abs(event.deltaX / this.wrapperWidth);
                this.panOffset = Math.sign(event.deltaX) * this.easeOut(absOffset);
                this.changeSlideTrigger('panning', this.panOffset * multiplier);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.endPan = /**
         * @return {?}
         */
            function () {
                if (Math.abs(this.panOffset) > 0.5) {
                    this.changeSlideTrigger(/** @type {?} */ (-Math.sign(this.panOffset)));
                }
                else if (this.slideTrigger.value === 'panning') {
                    this.changeSlideTrigger();
                }
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        SliderComponent.prototype.swipe = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                this.changeSlideTrigger(/** @type {?} */ (direction));
            };
        /**
         * @param {?=} value
         * @param {?=} offset
         * @return {?}
         */
        SliderComponent.prototype.changeSlideTrigger = /**
         * @param {?=} value
         * @param {?=} offset
         * @return {?}
         */
            function (value, offset) {
                if (value === void 0) {
                    value = 'idle';
                }
                if (offset === void 0) {
                    offset = 0;
                }
                this.slideTrigger = {
                    value: (value === -1 && this.prevDisabled || value === 1 && this.nextDisabled) ? 'idle' : value,
                    params: { x: offset * 100 },
                };
                this.cd.detectChanges();
            };
        SliderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'skm-slider',
                        template: "<div class=\"skm-datepicker-slider\" [@slide]=\"slideTrigger\" (@slide.done)=\"done($event)\">\n  <ng-content></ng-content>\n</div>\n<button type=\"button\" class=\"skm-datepicker-pagination skm-prev\" (click)=\"slide(-1)\" [disabled]=\"prevDisabled\">&lsaquo;</button>\n<button type=\"button\" class=\"skm-datepicker-pagination skm-next\" (click)=\"slide(1)\" [disabled]=\"nextDisabled\">&rsaquo;</button>\n",
                        styles: [":host{display:block;position:relative;height:100%}.skm-datepicker-slider{display:flex;position:relative;left:-100%;height:100%}.skm-datepicker-pagination{position:absolute;top:0}.skm-datepicker-pagination.skm-prev{left:0}.skm-datepicker-pagination.skm-next{right:0}", "button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                        animations: [slide()],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
                { type: core.ChangeDetectorRef, },
                { type: core.NgZone, },
            ];
        };
        SliderComponent.propDecorators = {
            "prevDisabled": [{ type: core.Input },],
            "nextDisabled": [{ type: core.Input },],
            "slideDone": [{ type: core.Output },],
        };
        return SliderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ biggerStyle = animations.style({
        transform: 'scale(0.8)',
        opacity: 0,
    });
    var /** @type {?} */ smallerStyle = animations.style({
        transform: 'scale(1.3)',
        opacity: 0,
    });
    /**
     * @param {?=} timing
     * @return {?}
     */
    function zoom(timing) {
        if (timing === void 0) {
            timing = 175;
        }
        return animations.trigger('zoom', [
            animations.transition('void => in', [
                biggerStyle,
                animations.animate(timing),
            ]),
            animations.transition('void => out', [
                smallerStyle,
                animations.animate(timing),
            ]),
            animations.transition('in => void', [
                animations.animate(timing, smallerStyle),
            ]),
            animations.transition('out => void', [
                animations.animate(timing, biggerStyle),
            ]),
        ]);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ViewStrategy = (function () {
        function ViewStrategy() {
        }
        return ViewStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ViewComponent = (function () {
        function ViewComponent(viewStrategy) {
            this.viewStrategy = viewStrategy;
            this.itemChange = new core.EventEmitter();
            this.headerClick = new core.EventEmitter();
            this.ViewMode = ViewMode;
            this.prevDisabled = false;
            this.nextDisabled = false;
            this.regularTimestampFields = ['currentTimestamp', 'selectedTimestamp', 'minTimestamp', 'maxTimestamp'];
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        ViewComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (this.viewStrategy.viewMode !== ViewMode.Days) {
                    this.regularTimestampFields.forEach(function (field) {
                        if (field in changes) {
                            _this[field] = _this[field] ? _this.viewStrategy.normalizeTimestamp(_this[field]) : undefined;
                        }
                    });
                }
                if ('initialTimestamp' in changes) {
                    // Must be called after normalization of other timestamps for proper behavior of min-max range
                    this.initPanes(this.initialTimestamp);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        ViewComponent.prototype.trackIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} notPanning
         * @return {?}
         */
        ViewComponent.prototype.clickHeader = /**
         * @param {?} notPanning
         * @return {?}
         */
            function (notPanning) {
                if (notPanning) {
                    this.headerClick.emit(this.panes[this.visiblePaneIndex].values[0]);
                }
            };
        /**
         * @param {?} event
         * @param {?} pane
         * @param {?} notPanning
         * @return {?}
         */
        ViewComponent.prototype.selectItem = /**
         * @param {?} event
         * @param {?} pane
         * @param {?} notPanning
         * @return {?}
         */
            function (event, pane, notPanning) {
                if (notPanning) {
                    var /** @type {?} */ button = (event.target);
                    var /** @type {?} */ index = button.dataset["index"];
                    if (this.deselectEnabled && pane.values[index] === this.selectedTimestamp) {
                        this.itemChange.emit(undefined);
                    }
                    else {
                        this.itemChange.emit(pane.values[index]);
                    }
                }
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        ViewComponent.prototype.switchPanes = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                this.visiblePaneIndex = (3 + this.visiblePaneIndex + direction) % 3;
                var /** @type {?} */ index = (3 + this.visiblePaneIndex + direction) % 3;
                var /** @type {?} */ pane = this.panes[index];
                this.panes[index] = this.viewStrategy.makePane(pane.values[0], 3 * direction, pane.order, this.weekStart);
                this.updateDisabledStatus((3 + this.visiblePaneIndex - 1) % 3, (3 + this.visiblePaneIndex + 1) % 3);
            };
        /**
         * @param {?} timestamp
         * @return {?}
         */
        ViewComponent.prototype.initPanes = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                var _this = this;
                var /** @type {?} */ seed = this.viewStrategy.makeInitPanesSeed(timestamp);
                this.panes = [-1, 0, 1].map(function (i) { return _this.viewStrategy.makePane(seed, i, 0, _this.weekStart); });
                this.visiblePaneIndex = 1;
                this.updateDisabledStatus(0, 2);
            };
        /**
         * @param {?} prevIndex
         * @param {?} nextIndex
         * @return {?}
         */
        ViewComponent.prototype.updateDisabledStatus = /**
         * @param {?} prevIndex
         * @param {?} nextIndex
         * @return {?}
         */
            function (prevIndex, nextIndex) {
                this.prevDisabled = this.panes[prevIndex].values[this.panes[prevIndex].values.length - 1] < this.minTimestamp;
                this.nextDisabled = this.panes[nextIndex].values[0] > this.maxTimestamp;
            };
        ViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'skm-view',
                        template: "<skm-slider [prevDisabled]=\"prevDisabled\" [nextDisabled]=\"nextDisabled\" (slideDone)=\"switchPanes($event)\" #slider>\n  <div class=\"skm-datepicker-pane\" *ngFor=\"let pane of panes; trackBy: trackIndex\" [style.order]=\"pane.order\">\n    <button type=\"button\" class=\"skm-datepicker-header\"\n            (click)=\"clickHeader(slider.notPanning)\" [disabled]=\"viewStrategy.viewMode === ViewMode.Years\">\n      {{pane.values[0] | date:headingFormat}}\n      <ng-container *ngIf=\"viewStrategy.viewMode === ViewMode.Years\">\n        &ndash; {{pane.values[19] | date:headingFormat}}\n      </ng-container>\n    </button>\n    <div class=\"skm-datepicker-week\" *ngIf=\"viewStrategy.viewMode === ViewMode.Days\">\n      <div class=\"skm-datepicker-weekday\" *ngFor=\"let label of weekDayLabels | slice:weekStart:7\">{{label}}</div>\n      <div class=\"skm-datepicker-weekday\" *ngFor=\"let label of weekDayLabels | slice:0:weekStart\">{{label}}</div>\n    </div>\n    <skm-grid\n      [pane]=\"pane\"\n      [currentTimestamp]=\"currentTimestamp\"\n      [selectedTimestamp]=\"selectedTimestamp\"\n      [minTimestamp]=\"minTimestamp\"\n      [maxTimestamp]=\"maxTimestamp\"\n      [itemFormat]=\"itemFormat\"\n      [itemLabels]=\"itemLabels\"\n    ></skm-grid>\n  </div>\n</skm-slider>\n",
                        styles: ["button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                        animations: [zoom()],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        ViewComponent.ctorParameters = function () {
            return [
                { type: ViewStrategy, },
            ];
        };
        ViewComponent.propDecorators = {
            "zoomDirection": [{ type: core.Input }, { type: core.HostBinding, args: ['@zoom',] },],
            "initialTimestamp": [{ type: core.Input },],
            "currentTimestamp": [{ type: core.Input },],
            "selectedTimestamp": [{ type: core.Input },],
            "minTimestamp": [{ type: core.Input },],
            "maxTimestamp": [{ type: core.Input },],
            "deselectEnabled": [{ type: core.Input },],
            "headingFormat": [{ type: core.Input },],
            "weekStart": [{ type: core.Input },],
            "weekDayLabels": [{ type: core.Input },],
            "itemFormat": [{ type: core.Input },],
            "itemLabels": [{ type: core.Input },],
            "itemChange": [{ type: core.Output },],
            "headerClick": [{ type: core.Output },],
        };
        return ViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GridComponent = (function () {
        function GridComponent(slider, parentView, viewStrategy) {
            this.slider = slider;
            this.parentView = parentView;
            this.viewStrategy = viewStrategy;
            this.itemLabels = [];
            this._hostClass = 'skm-datepicker-content';
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        GridComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if ('itemLabels' in changes) {
                    this.itemLabels = this.itemLabels || [];
                }
            };
        /**
         * @param {?} index
         * @param {?} pane
         * @return {?}
         */
        GridComponent.prototype.makeItemClasses = /**
         * @param {?} index
         * @param {?} pane
         * @return {?}
         */
            function (index, pane) {
                return [
                    this.viewStrategy.itemClass,
                    'skm-datepicker-item',
                    (pane.values[index] === this.currentTimestamp) ? 'skm-datepicker-current' : '',
                    (pane.values[index] === this.selectedTimestamp) ? 'skm-datepicker-selected' : '',
                ].join(' ');
            };
        /**
         * @param {?} index
         * @param {?} pane
         * @return {?}
         */
        GridComponent.prototype.isDisabled = /**
         * @param {?} index
         * @param {?} pane
         * @return {?}
         */
            function (index, pane) {
                return (pane.values[index] < this.minTimestamp) || (pane.values[index] > this.maxTimestamp);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        GridComponent.prototype.trackIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        GridComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'skm-grid',
                        template: "<div class=\"skm-datepicker-grid\" (click)=\"parentView.selectItem($event, pane, slider.notPanning)\">\n  <div class=\"skm-datepicker-indent\" [style.width.%]=\"100 / 7 * pane.indent\"></div>\n  <div *ngFor=\"let value of pane.values; trackBy: trackIndex; let i = index\" class=\"skm-datepicker-cell\">\n    <button type=\"button\" [attr.data-index]=\"i\" [class]=\"makeItemClasses(i, pane)\" [disabled]=\"isDisabled(i, pane)\">\n      {{itemLabels[i] || (value | date:itemFormat)}}\n    </button>\n  </div>\n</div>\n",
                        styles: ["button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        GridComponent.ctorParameters = function () {
            return [
                { type: SliderComponent, },
                { type: ViewComponent, },
                { type: ViewStrategy, },
            ];
        };
        GridComponent.propDecorators = {
            "pane": [{ type: core.Input },],
            "currentTimestamp": [{ type: core.Input },],
            "selectedTimestamp": [{ type: core.Input },],
            "minTimestamp": [{ type: core.Input },],
            "maxTimestamp": [{ type: core.Input },],
            "itemFormat": [{ type: core.Input },],
            "itemLabels": [{ type: core.Input },],
            "_hostClass": [{ type: core.HostBinding, args: ['class',] },],
        };
        return GridComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DaysStrategyDirective = (function (_super) {
        __extends(DaysStrategyDirective, _super);
        function DaysStrategyDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.viewMode = ViewMode.Days;
            _this.itemClass = 'skm-datepicker-day';
            return _this;
        }
        /**
         * @param {?} timestamp
         * @return {?}
         */
        DaysStrategyDirective.prototype.normalizeTimestamp = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                return timestamp;
            };
        /**
         * @param {?} timestamp
         * @return {?}
         */
        DaysStrategyDirective.prototype.makeInitPanesSeed = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                return startOfMonth(timestamp).valueOf();
            };
        /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
        DaysStrategyDirective.prototype.makePane = /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
            function (timestamp, add, baseOrder, weekStart) {
                var /** @type {?} */ date = new Date(timestamp);
                date.setMonth(add + date.getMonth());
                var /** @type {?} */ firstDay = date.getDay();
                date.setMonth(1 + date.getMonth());
                date.setDate(0);
                var /** @type {?} */ monthLength = date.getDate();
                var /** @type {?} */ values = [];
                for (var /** @type {?} */ i = 1; i <= monthLength; i++) {
                    values.push(date.setDate(i));
                }
                return {
                    order: baseOrder + add,
                    values: values,
                    indent: (firstDay - weekStart + 7) % 7 || 7,
                };
            };
        DaysStrategyDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[skmDaysStrategy]',
                        providers: [
                            { provide: ViewStrategy, useExisting: DaysStrategyDirective },
                        ],
                    },] },
        ];
        return DaysStrategyDirective;
    }(ViewStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthsStrategyDirective = (function (_super) {
        __extends(MonthsStrategyDirective, _super);
        function MonthsStrategyDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.viewMode = ViewMode.Months;
            _this.itemClass = 'skm-datepicker-month';
            return _this;
        }
        /**
         * @param {?} timestamp
         * @return {?}
         */
        MonthsStrategyDirective.prototype.normalizeTimestamp = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                return new Date(timestamp).setDate(1);
            };
        /**
         * @param {?} timestamp
         * @return {?}
         */
        MonthsStrategyDirective.prototype.makeInitPanesSeed = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                return startOfYear(timestamp).valueOf();
            };
        /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
        MonthsStrategyDirective.prototype.makePane = /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
            function (timestamp, add, baseOrder, weekStart) {
                var /** @type {?} */ date = new Date(timestamp);
                date.setFullYear(add + date.getFullYear());
                var /** @type {?} */ values = [];
                for (var /** @type {?} */ i = 0; i < 12; i++) {
                    values.push(date.setMonth(i));
                }
                return {
                    order: baseOrder + add,
                    values: values,
                };
            };
        MonthsStrategyDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[skmMonthsStrategy]',
                        providers: [
                            { provide: ViewStrategy, useExisting: MonthsStrategyDirective },
                        ],
                    },] },
        ];
        return MonthsStrategyDirective;
    }(ViewStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearsStrategyDirective = (function (_super) {
        __extends(YearsStrategyDirective, _super);
        function YearsStrategyDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.viewMode = ViewMode.Years;
            _this.itemClass = 'skm-datepicker-year';
            return _this;
        }
        /**
         * @param {?} timestamp
         * @return {?}
         */
        YearsStrategyDirective.prototype.normalizeTimestamp = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                return new Date(timestamp).setMonth(0, 1);
            };
        /**
         * @param {?} timestamp
         * @return {?}
         */
        YearsStrategyDirective.prototype.makeInitPanesSeed = /**
         * @param {?} timestamp
         * @return {?}
         */
            function (timestamp) {
                var /** @type {?} */ date = new Date(timestamp);
                var /** @type {?} */ origin = date.getFullYear();
                var /** @type {?} */ adjusted = origin - (origin % 20);
                return startOfYear(date).setFullYear(adjusted);
            };
        /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
        YearsStrategyDirective.prototype.makePane = /**
         * @param {?} timestamp
         * @param {?} add
         * @param {?} baseOrder
         * @param {?} weekStart
         * @return {?}
         */
            function (timestamp, add, baseOrder, weekStart) {
                var /** @type {?} */ date = new Date(timestamp);
                var /** @type {?} */ origin = add * 20 + date.getFullYear();
                var /** @type {?} */ values = [];
                for (var /** @type {?} */ i = 0; i < 20; i++) {
                    values.push(date.setFullYear(origin + i));
                }
                return {
                    order: baseOrder + add,
                    values: values,
                };
            };
        YearsStrategyDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[skmYearsStrategy]',
                        providers: [
                            { provide: ViewStrategy, useExisting: YearsStrategyDirective },
                        ],
                    },] },
        ];
        return YearsStrategyDirective;
    }(ViewStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DatepickerModule = (function () {
        function DatepickerModule() {
        }
        DatepickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        declarations: [
                            DatepickerComponent,
                            ViewComponent,
                            SliderComponent,
                            GridComponent,
                            DaysStrategyDirective,
                            MonthsStrategyDirective,
                            YearsStrategyDirective,
                        ],
                        exports: [
                            DatepickerComponent,
                        ],
                    },] },
        ];
        return DatepickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.DatepickerComponent = DatepickerComponent;
    exports.DatepickerModule = DatepickerModule;
    exports.ViewMode = ViewMode;
    exports.ɵf = GridComponent;
    exports.ɵe = slide;
    exports.ɵd = SliderComponent;
    exports.ɵb = zoom;
    exports.ɵg = DaysStrategyDirective;
    exports.ɵh = MonthsStrategyDirective;
    exports.ɵc = ViewStrategy;
    exports.ɵi = YearsStrategyDirective;
    exports.ɵa = ViewComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2tpbW1lZC1kYXRlcGlja2VyLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi91dGlsL2hlbHBlcnMudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvZGF0ZXBpY2tlci92aWV3LW1vZGUudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudC50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9zbGlkZXIvc2xpZGUuYW5pbWF0aW9uLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3NsaWRlci9zbGlkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3V0aWwvem9vbS5hbmltYXRpb24udHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdmlldy1zdHJhdGVnaWVzL3ZpZXctc3RyYXRlZ3kudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdmlldy92aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9ncmlkL2dyaWQuY29tcG9uZW50LnRzIixudWxsLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy9tb250aHMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy95ZWFycy1zdHJhdGVneS5kaXJlY3RpdmUudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvZGF0ZXBpY2tlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcclxuICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZEYXkoZGF0ZTogRGF0ZSB8IG51bWJlcik6IERhdGUge1xyXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlIGFzIG51bWJlcik7XHJcbiAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aChkYXRlOiBEYXRlIHwgbnVtYmVyKTogRGF0ZSB7XHJcbiAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUgYXMgbnVtYmVyKTtcclxuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG4gIGQuc2V0RGF0ZSgxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZZZWFyKGRhdGU6IERhdGUgfCBudW1iZXIpOiBEYXRlIHtcclxuICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSBhcyBudW1iZXIpO1xyXG4gIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgZC5zZXRNb250aCgwLCAxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuLy8ga3Vkb3MgdG8gQG1pY2hlbDRuZ2VsMFxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWFzZU91dChwYW5SYXRpbzogbnVtYmVyKTogKHg6IG51bWJlcikgPT4gbnVtYmVyIHtcclxuICBjb25zdCBhID0gKHBhblJhdGlvIC0gMikgLyBwYW5SYXRpbyAqKiAzO1xyXG4gIGNvbnN0IGIgPSAoMyAtIDIgKiBwYW5SYXRpbykgLyBwYW5SYXRpbyAqKiAyO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gZWFzZU91dCh4OiBudW1iZXIpIHtcclxuICAgIHJldHVybiAoeCA+PSBwYW5SYXRpbykgPyAxIDogKChhICogeCArIGIpICogeCArIDEpICogeDtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcclxufVxyXG4iLCJleHBvcnQgZW51bSBWaWV3TW9kZSB7XHJcbiAgRGF5cyA9ICdkYXlzJyxcclxuICBNb250aHMgPSAnbW9udGhzJyxcclxuICBZZWFycyA9ICd5ZWFycycsXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBMT0NBTEVfSUQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRm9ybVN0eWxlLCBnZXRMb2NhbGVEYXlOYW1lcywgVHJhbnNsYXRpb25XaWR0aCwgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgaXNWYWxpZERhdGUsIG5vb3AsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4vdmlldy1tb2RlJztcclxuaW1wb3J0IHsgWm9vbURpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWwvem9vbS5hbmltYXRpb24nO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZGF0ZXBpY2tlcicsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXJcIiBbbmdTd2l0Y2hdPVwidmlld1wiPlxyXG4gIDxza20tdmlld1xyXG4gICAgKm5nU3dpdGNoQ2FzZT1cIlZpZXdNb2RlLkRheXNcIlxyXG4gICAgc2ttRGF5c1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3XCJcclxuICAgIFt6b29tRGlyZWN0aW9uXT1cInpvb21EaXJlY3Rpb25cIlxyXG4gICAgW2luaXRpYWxUaW1lc3RhbXBdPVwiaW5pdGlhbFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2N1cnJlbnRUaW1lc3RhbXBdPVwiY3VycmVudFRpbWVzdGFtcFwiXHJcbiAgICBbc2VsZWN0ZWRUaW1lc3RhbXBdPVwic2VsZWN0ZWRUaW1lc3RhbXBcIlxyXG4gICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgW21heFRpbWVzdGFtcF09XCJtYXhUaW1lc3RhbXBcIlxyXG5cclxuICAgIFtkZXNlbGVjdEVuYWJsZWRdPVwiZGVzZWxlY3RFbmFibGVkXCJcclxuXHJcbiAgICBbaGVhZGluZ0Zvcm1hdF09XCJoZWFkaW5nRm9ybWF0XCJcclxuICAgIFt3ZWVrU3RhcnRdPVwid2Vla1N0YXJ0XCJcclxuICAgIFt3ZWVrRGF5TGFiZWxzXT1cIndlZWtEYXlMYWJlbHNcIlxyXG4gICAgW2l0ZW1Gb3JtYXRdPVwiZGF5Rm9ybWF0XCJcclxuICAgIFtpdGVtTGFiZWxzXT1cImRheUxhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5Nb250aHMsICdvdXQnKVwiXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzZWxlY3REYXkoJGV2ZW50KVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuTW9udGhzXCJcclxuICAgIHNrbU1vbnRoc1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItbW9udGhzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJtb250aEZvcm1hdFwiXHJcbiAgICBbaXRlbUxhYmVsc109XCJtb250aExhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5ZZWFycywgJ291dCcpXCJcclxuICAgIChpdGVtQ2hhbmdlKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5EYXlzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuWWVhcnNcIlxyXG4gICAgc2ttWWVhcnNTdHJhdGVneVxyXG4gICAgY2xhc3M9XCJza20tZGF0ZXBpY2tlci12aWV3IHNrbS1kYXRlcGlja2VyLXllYXJzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJ5ZWFyRm9ybWF0XCJcclxuXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzd2l0Y2hWaWV3KCRldmVudCwgVmlld01vZGUuTW9udGhzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2Auc2ttLWRhdGVwaWNrZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci12aWV3e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX1gLCBgYnV0dG9ue2Rpc3BsYXk6YmxvY2s7Y29sb3I6aW5oZXJpdH1idXR0b246bm90KFtkaXNhYmxlZF0pe2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF17cG9pbnRlci1ldmVudHM6bm9uZX0uc2ttLWRhdGVwaWNrZXItcGFuZXtmbGV4LXNocmluazowO3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtvdmVyZmxvdzpoaWRkZW59LnNrbS1kYXRlcGlja2VyLXdlZWt7ZGlzcGxheTpmbGV4fS5za20tZGF0ZXBpY2tlci13ZWVrZGF5e3dpZHRoOjE0LjI4NTcxJX0uc2ttLWRhdGVwaWNrZXItY29udGVudHtmbGV4OjEgMCAwO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LnNrbS1kYXRlcGlja2VyLWdyaWR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXA7YWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLWluZGVudHtoZWlnaHQ6MTYuNjY2NjclfS5za20tZGF0ZXBpY2tlci1jZWxse2Rpc3BsYXk6ZmxleH06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1kYXlzLXZpZXcpIC5za20tZGF0ZXBpY2tlci1jZWxse3dpZHRoOjE0LjI4NTcxJTtoZWlnaHQ6MTYuNjY2NjclfTpob3N0LWNvbnRleHQoLnNrbS1kYXRlcGlja2VyLW1vbnRocy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDozMy4zMzMzMyU7aGVpZ2h0OjI1JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci15ZWFycy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoyMCU7aGVpZ2h0OjI1JX0uc2ttLWRhdGVwaWNrZXItaXRlbXtmbGV4OjE7cG9pbnRlci1ldmVudHM6YXV0b31gXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IERhdGVwaWNrZXJDb21wb25lbnQsIG11bHRpOiB0cnVlfSxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMsIE9uSW5pdCB7XHJcbiAgQElucHV0KCkgc2V0IGRhdGUoZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBpZiAoZGlydHlEYXRlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0ZSA9IHN0YXJ0T2ZEYXkoZGlydHlEYXRlKTtcclxuICAgIGlmIChkYXRlLmdldFRpbWUoKSAhPT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICB0aGlzLnNlbGVjdGVkVGltZXN0YW1wID0gaXNWYWxpZERhdGUoZGF0ZSkgPyBkYXRlLmdldFRpbWUoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGVkVGltZXN0YW1wICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFRpbWVzdGFtcCA9IHRoaXMuc2VsZWN0ZWRUaW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gVmlld01vZGUuRGF5cztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQE91dHB1dCgpIGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XHJcblxyXG4gIEBJbnB1dCgpIHNldCBtaW4oZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBkYXRlID0gc3RhcnRPZkRheShkaXJ0eURhdGUpO1xyXG4gICAgdGhpcy5taW5UaW1lc3RhbXAgPSBpc1ZhbGlkRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgc2V0IG1heChkaXJ0eURhdGU6IERhdGUgfCBudW1iZXIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZSk7XHJcbiAgICB0aGlzLm1heFRpbWVzdGFtcCA9IGlzVmFsaWREYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGRheUZvcm1hdCA9ICdkJztcclxuICBASW5wdXQoKSBtb250aEZvcm1hdCA9ICdNTU0nO1xyXG4gIEBJbnB1dCgpIHllYXJGb3JtYXQgPSAneSc7XHJcbiAgQElucHV0KCkgaGVhZGluZ0Zvcm1hdCA9ICdNTU1NIHknO1xyXG4gIEBJbnB1dCgpIHdlZWtTdGFydCA9IFdlZWtEYXkuTW9uZGF5O1xyXG5cclxuICBASW5wdXQoKSBkYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIHdlZWtEYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIG1vbnRoTGFiZWxzOiBzdHJpbmdbXTtcclxuXHJcbiAgQElucHV0KCkgdmlldyA9IFZpZXdNb2RlLkRheXM7XHJcblxyXG4gIGluaXRpYWxUaW1lc3RhbXA6IG51bWJlcjtcclxuICBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwcml2YXRlIG9uQ2hhbmdlOiAoZGF0ZTogRGF0ZSkgPT4gdm9pZCA9IG5vb3A7XHJcbiAgcHJpdmF0ZSBvblRvdWNoZWQ6ICgpID0+IHZvaWQgPSBub29wO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgbG9jYWxlOiBzdHJpbmcpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnd2Vla0RheUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLndlZWtEYXlMYWJlbHMgPSB0aGlzLndlZWtEYXlMYWJlbHMgfHwgZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50VGltZXN0YW1wID0gc3RhcnRPZkRheShuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wIHx8IHRoaXMuY3VycmVudFRpbWVzdGFtcDtcclxuICAgIHRoaXMud2Vla0RheUxhYmVscyA9IHRoaXMud2Vla0RheUxhYmVscyB8fCBnZXRMb2NhbGVEYXlOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLlN0YW5kYWxvbmUsIFRyYW5zbGF0aW9uV2lkdGguQWJicmV2aWF0ZWQpO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0RGF5KHRpbWVzdGFtcDogbnVtYmVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xyXG4gICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgIGNvbnN0IGRhdGUgPSAodHlwZW9mIHRpbWVzdGFtcCAhPT0gJ3VuZGVmaW5lZCcpID8gbmV3IERhdGUodGltZXN0YW1wKSA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XHJcbiAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaFZpZXcodGltZXN0YW1wOiBudW1iZXIsIHZpZXc6IFZpZXdNb2RlLCBkaXJlY3Rpb246IFpvb21EaXJlY3Rpb24pIHtcclxuICAgIHRoaXMuem9vbURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGltcGxlbWVudGF0aW9uXHJcblxyXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuZGF0ZSA9IG9iajtcclxuICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgfVxyXG5cclxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gIH1cclxuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUodGltaW5nOiBudW1iZXIgfCBzdHJpbmcgPSAxNTApOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEge1xyXG4gIHJldHVybiB0cmlnZ2VyKCdzbGlkZScsIFtcclxuICAgIHN0YXRlKCdwYW5uaW5nJywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKHt7eH19JSknLFxyXG4gICAgfSksIHtwYXJhbXM6IHt4OiAwfX0pLFxyXG4gICAgdHJhbnNpdGlvbignKiA9PiAxJywgYW5pbWF0ZSh0aW1pbmcsIHN0eWxlKHtcclxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLFxyXG4gICAgfSkpKSxcclxuICAgIHRyYW5zaXRpb24oJyogPT4gLTEnLCBhbmltYXRlKHRpbWluZywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyxcclxuICAgIH0pKSksXHJcbiAgICB0cmFuc2l0aW9uKCdwYW5uaW5nID0+IGlkbGUnLCBhbmltYXRlKHRpbWluZykpLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgTmdab25lLFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3V0cHV0LFxyXG4gIFNpbXBsZUNoYW5nZXMsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNyZWF0ZUVhc2VPdXQgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBzbGlkZSB9IGZyb20gJy4vc2xpZGUuYW5pbWF0aW9uJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmRlY2xhcmUgY2xhc3MgSGFtbWVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gIGNvbnN0cnVjdG9yKHRhcmdldDogRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblRyaWdnZXIge1xyXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgcGFyYW1zOiB7IFtwOiBzdHJpbmddOiBhbnkgfTtcclxufVxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tc2xpZGVyJyxcclxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1zbGlkZXJcIiBbQHNsaWRlXT1cInNsaWRlVHJpZ2dlclwiIChAc2xpZGUuZG9uZSk9XCJkb25lKCRldmVudClcIj5cclxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbjwvZGl2PlxyXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24gc2ttLXByZXZcIiAoY2xpY2spPVwic2xpZGUoLTEpXCIgW2Rpc2FibGVkXT1cInByZXZEaXNhYmxlZFwiPiZsc2FxdW87PC9idXR0b24+XHJcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2ttLWRhdGVwaWNrZXItcGFnaW5hdGlvbiBza20tbmV4dFwiIChjbGljayk9XCJzbGlkZSgxKVwiIFtkaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIj4mcnNhcXVvOzwvYnV0dG9uPlxyXG5gLFxyXG4gIHN0eWxlczogW2A6aG9zdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlfS5za20tZGF0ZXBpY2tlci1zbGlkZXJ7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTEwMCU7aGVpZ2h0OjEwMCV9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb257cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24uc2ttLXByZXZ7bGVmdDowfS5za20tZGF0ZXBpY2tlci1wYWdpbmF0aW9uLnNrbS1uZXh0e3JpZ2h0OjB9YCwgYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3NsaWRlKCldLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xyXG4gIEBJbnB1dCgpIHByZXZEaXNhYmxlZCA9IGZhbHNlO1xyXG4gIEBJbnB1dCgpIG5leHREaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICBAT3V0cHV0KCkgc2xpZGVEb25lID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XHJcbiAgbm90UGFubmluZyA9IHRydWU7XHJcblxyXG4gIHNsaWRlVHJpZ2dlcjogQW5pbWF0aW9uVHJpZ2dlcjtcclxuXHJcbiAgcHJpdmF0ZSB3cmFwcGVyV2lkdGggPSAxO1xyXG4gIHByaXZhdGUgcGFuT2Zmc2V0ID0gMDtcclxuICBwcml2YXRlIGxhc3REb25lRXZlbnRUb1N0YXRlOiBzdHJpbmcgfCBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbmdVbnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdCgpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZWFzZU91dCA9IGNyZWF0ZUVhc2VPdXQoMS4zKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHRoaXMuY2QuZGV0YWNoKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgY29uc3QgaG9zdCA9IHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50O1xyXG4gICAgICBmcm9tRXZlbnQoaG9zdCwgJ21vdXNlZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFByZXNzKCkpO1xyXG5cclxuICAgICAgaWYgKCdIYW1tZXInIGluIHdpbmRvdykge1xyXG4gICAgICAgIGNvbnN0IGhhbW1lciA9IG5ldyBIYW1tZXIoaG9zdCk7XHJcblxyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdwYW5zdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFBhbigpKTtcclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAncGFubW92ZScpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoZSA9PiB0aGlzLnBhbihlKSk7XHJcbiAgICAgICAgZnJvbUV2ZW50KGhhbW1lciwgJ3BhbmVuZCBwYW5jYW5jZWwnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZW5kUGFuKCkpO1xyXG5cclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAnc3dpcGVyaWdodCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zd2lwZSgtMSkpO1xyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdzd2lwZWxlZnQnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3dpcGUoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5uZXh0KCk7XHJcbiAgICB0aGlzLm5nVW5zdWJzY3JpYmUkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBkb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09IHRoaXMubGFzdERvbmVFdmVudFRvU3RhdGUpIHtcclxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjQwODRcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sYXN0RG9uZUV2ZW50VG9TdGF0ZSA9IGV2ZW50LnRvU3RhdGU7XHJcbiAgICBpZiAodHlwZW9mIGV2ZW50LnRvU3RhdGUgYXMgc3RyaW5nIHwgbnVtYmVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICB0aGlzLnNsaWRlRG9uZS5lbWl0KGV2ZW50LnRvU3RhdGUgYXMgYW55KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNsaWRlKGRpcmVjdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcihkaXJlY3Rpb24gYXMgLTEgfCAxKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0UHJlc3MoKTogdm9pZCB7XHJcbiAgICB0aGlzLm5vdFBhbm5pbmcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydFBhbigpOiB2b2lkIHtcclxuICAgIHRoaXMubm90UGFubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFuKGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZXZlbnQuZGVsdGFYID4gMCAmJiB0aGlzLnByZXZEaXNhYmxlZCB8fCBldmVudC5kZWx0YVggPCAwICYmIHRoaXMubmV4dERpc2FibGVkKSA/IDAuMSA6IDE7XHJcbiAgICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhldmVudC5kZWx0YVggLyB0aGlzLndyYXBwZXJXaWR0aCk7XHJcbiAgICB0aGlzLnBhbk9mZnNldCA9IE1hdGguc2lnbihldmVudC5kZWx0YVgpICogdGhpcy5lYXNlT3V0KGFic09mZnNldCk7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigncGFubmluZycsIHRoaXMucGFuT2Zmc2V0ICogbXVsdGlwbGllcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGVuZFBhbigpOiB2b2lkIHtcclxuICAgIGlmIChNYXRoLmFicyh0aGlzLnBhbk9mZnNldCkgPiAwLjUpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoLU1hdGguc2lnbih0aGlzLnBhbk9mZnNldCkgYXMgLTEgfCAxKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zbGlkZVRyaWdnZXIudmFsdWUgPT09ICdwYW5uaW5nJykge1xyXG4gICAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzd2lwZShkaXJlY3Rpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoZGlyZWN0aW9uIGFzIC0xIHwgMSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoYW5nZVNsaWRlVHJpZ2dlcih2YWx1ZTogJ3Bhbm5pbmcnIHwgJ2lkbGUnIHwgLTEgfCAxID0gJ2lkbGUnLCBvZmZzZXQgPSAwKTogdm9pZCB7XHJcbiAgICB0aGlzLnNsaWRlVHJpZ2dlciA9IHtcclxuICAgICAgdmFsdWU6ICh2YWx1ZSA9PT0gLTEgJiYgdGhpcy5wcmV2RGlzYWJsZWQgfHwgdmFsdWUgPT09IDEgJiYgdGhpcy5uZXh0RGlzYWJsZWQpID8gJ2lkbGUnIDogdmFsdWUsXHJcbiAgICAgIHBhcmFtczoge3g6IG9mZnNldCAqIDEwMH0sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgdHlwZSBab29tRGlyZWN0aW9uID0gJ2luJyB8ICdvdXQnO1xyXG5cclxuY29uc3QgYmlnZ2VyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5jb25zdCBzbWFsbGVyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMS4zKScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gem9vbSh0aW1pbmc6IG51bWJlciB8IHN0cmluZyA9IDE3NSk6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSB7XHJcbiAgcmV0dXJuIHRyaWdnZXIoJ3pvb20nLCBbXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IGluJywgW1xyXG4gICAgICBiaWdnZXJTdHlsZSxcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IG91dCcsIFtcclxuICAgICAgc21hbGxlclN0eWxlLFxyXG4gICAgICBhbmltYXRlKHRpbWluZyksXHJcbiAgICBdKSxcclxuICAgIHRyYW5zaXRpb24oJ2luID0+IHZvaWQnLCBbXHJcbiAgICAgIGFuaW1hdGUodGltaW5nLCBzbWFsbGVyU3R5bGUpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCdvdXQgPT4gdm9pZCcsIFtcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcsIGJpZ2dlclN0eWxlKSxcclxuICAgIF0pLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZpZXdTdHJhdGVneSB7XHJcbiAgYWJzdHJhY3QgcmVhZG9ubHkgdmlld01vZGU6IFZpZXdNb2RlO1xyXG4gIGFic3RyYWN0IHJlYWRvbmx5IGl0ZW1DbGFzczogc3RyaW5nO1xyXG5cclxuICBhYnN0cmFjdCBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gIGFic3RyYWN0IG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICBhYnN0cmFjdCBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lO1xyXG59XHJcbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyB6b29tLCBab29tRGlyZWN0aW9uIH0gZnJvbSAnLi4vdXRpbC96b29tLmFuaW1hdGlvbic7XHJcbmltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuLi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3NrbS12aWV3JyxcclxuICB0ZW1wbGF0ZTogYDxza20tc2xpZGVyIFtwcmV2RGlzYWJsZWRdPVwicHJldkRpc2FibGVkXCIgW25leHREaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIiAoc2xpZGVEb25lKT1cInN3aXRjaFBhbmVzKCRldmVudClcIiAjc2xpZGVyPlxyXG4gIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1wYW5lXCIgKm5nRm9yPVwibGV0IHBhbmUgb2YgcGFuZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXhcIiBbc3R5bGUub3JkZXJdPVwicGFuZS5vcmRlclwiPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1oZWFkZXJcIlxyXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xpY2tIZWFkZXIoc2xpZGVyLm5vdFBhbm5pbmcpXCIgW2Rpc2FibGVkXT1cInZpZXdTdHJhdGVneS52aWV3TW9kZSA9PT0gVmlld01vZGUuWWVhcnNcIj5cclxuICAgICAge3twYW5lLnZhbHVlc1swXSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ2aWV3U3RyYXRlZ3kudmlld01vZGUgPT09IFZpZXdNb2RlLlllYXJzXCI+XHJcbiAgICAgICAgJm5kYXNoOyB7e3BhbmUudmFsdWVzWzE5XSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla1wiICpuZ0lmPVwidmlld1N0cmF0ZWd5LnZpZXdNb2RlID09PSBWaWV3TW9kZS5EYXlzXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci13ZWVrZGF5XCIgKm5nRm9yPVwibGV0IGxhYmVsIG9mIHdlZWtEYXlMYWJlbHMgfCBzbGljZTp3ZWVrU3RhcnQ6N1wiPnt7bGFiZWx9fTwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla2RheVwiICpuZ0Zvcj1cImxldCBsYWJlbCBvZiB3ZWVrRGF5TGFiZWxzIHwgc2xpY2U6MDp3ZWVrU3RhcnRcIj57e2xhYmVsfX08L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPHNrbS1ncmlkXHJcbiAgICAgIFtwYW5lXT1cInBhbmVcIlxyXG4gICAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgICAgW3NlbGVjdGVkVGltZXN0YW1wXT1cInNlbGVjdGVkVGltZXN0YW1wXCJcclxuICAgICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcbiAgICAgIFtpdGVtRm9ybWF0XT1cIml0ZW1Gb3JtYXRcIlxyXG4gICAgICBbaXRlbUxhYmVsc109XCJpdGVtTGFiZWxzXCJcclxuICAgID48L3NrbS1ncmlkPlxyXG4gIDwvZGl2PlxyXG48L3NrbS1zbGlkZXI+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3pvb20oKV0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ0B6b29tJykgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICBASW5wdXQoKSBpbml0aWFsVGltZXN0YW1wOiBudW1iZXI7XHJcblxyXG4gIEBJbnB1dCgpIGN1cnJlbnRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBzZWxlY3RlZFRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1pblRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1heFRpbWVzdGFtcDogbnVtYmVyO1xyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGhlYWRpbmdGb3JtYXQ6IHN0cmluZztcclxuICBASW5wdXQoKSB3ZWVrU3RhcnQ6IFdlZWtEYXk7XHJcbiAgQElucHV0KCkgd2Vla0RheUxhYmVsczogc3RyaW5nW107XHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdO1xyXG5cclxuICBAT3V0cHV0KCkgcmVhZG9ubHkgaXRlbUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG4gIEBPdXRwdXQoKSByZWFkb25seSBoZWFkZXJDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwYW5lczogQXJyYXk8UGFuZT47XHJcbiAgcHJldkRpc2FibGVkID0gZmFsc2U7XHJcbiAgbmV4dERpc2FibGVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSB2aXNpYmxlUGFuZUluZGV4OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSByZWd1bGFyVGltZXN0YW1wRmllbGRzID0gWydjdXJyZW50VGltZXN0YW1wJywgJ3NlbGVjdGVkVGltZXN0YW1wJywgJ21pblRpbWVzdGFtcCcsICdtYXhUaW1lc3RhbXAnXTtcclxuXHJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnZpZXdTdHJhdGVneS52aWV3TW9kZSAhPT0gVmlld01vZGUuRGF5cykge1xyXG4gICAgICB0aGlzLnJlZ3VsYXJUaW1lc3RhbXBGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgaWYgKGZpZWxkIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXNbZmllbGRdID0gdGhpc1tmaWVsZF0gPyB0aGlzLnZpZXdTdHJhdGVneS5ub3JtYWxpemVUaW1lc3RhbXAodGhpc1tmaWVsZF0pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ2luaXRpYWxUaW1lc3RhbXAnIGluIGNoYW5nZXMpIHtcclxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgbm9ybWFsaXphdGlvbiBvZiBvdGhlciB0aW1lc3RhbXBzIGZvciBwcm9wZXIgYmVoYXZpb3Igb2YgbWluLW1heCByYW5nZVxyXG4gICAgICB0aGlzLmluaXRQYW5lcyh0aGlzLmluaXRpYWxUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIGNsaWNrSGVhZGVyKG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIHRoaXMuaGVhZGVyQ2xpY2suZW1pdCh0aGlzLnBhbmVzW3RoaXMudmlzaWJsZVBhbmVJbmRleF0udmFsdWVzWzBdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlbGVjdEl0ZW0oZXZlbnQ6IE1vdXNlRXZlbnQsIHBhbmU6IFBhbmUsIG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgICAgY29uc3QgaW5kZXggPSBidXR0b24uZGF0YXNldC5pbmRleDtcclxuICAgICAgaWYgKHRoaXMuZGVzZWxlY3RFbmFibGVkICYmIHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICAgIHRoaXMuaXRlbUNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pdGVtQ2hhbmdlLmVtaXQocGFuZS52YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3dpdGNoUGFuZXMoZGlyZWN0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudmlzaWJsZVBhbmVJbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBpbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBwYW5lID0gdGhpcy5wYW5lc1tpbmRleF07XHJcbiAgICB0aGlzLnBhbmVzW2luZGV4XSA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VQYW5lKHBhbmUudmFsdWVzWzBdLCAzICogZGlyZWN0aW9uLCBwYW5lLm9yZGVyLCB0aGlzLndlZWtTdGFydCk7XHJcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkU3RhdHVzKCgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4IC0gMSkgJSAzLCAoMyArIHRoaXMudmlzaWJsZVBhbmVJbmRleCArIDEpICUgMyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRQYW5lcyh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc2VlZCA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcCk7XHJcbiAgICB0aGlzLnBhbmVzID0gWy0xLCAwLCAxXS5tYXAoaSA9PiB0aGlzLnZpZXdTdHJhdGVneS5tYWtlUGFuZShzZWVkLCBpLCAwLCB0aGlzLndlZWtTdGFydCkpO1xyXG4gICAgdGhpcy52aXNpYmxlUGFuZUluZGV4ID0gMTtcclxuICAgIHRoaXMudXBkYXRlRGlzYWJsZWRTdGF0dXMoMCwgMik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZURpc2FibGVkU3RhdHVzKHByZXZJbmRleDogbnVtYmVyLCBuZXh0SW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5wcmV2RGlzYWJsZWQgPSB0aGlzLnBhbmVzW3ByZXZJbmRleF0udmFsdWVzW3RoaXMucGFuZXNbcHJldkluZGV4XS52YWx1ZXMubGVuZ3RoIC0gMV0gPCB0aGlzLm1pblRpbWVzdGFtcDtcclxuICAgIHRoaXMubmV4dERpc2FibGVkID0gdGhpcy5wYW5lc1tuZXh0SW5kZXhdLnZhbHVlc1swXSA+IHRoaXMubWF4VGltZXN0YW1wO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuLi9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFZpZXdTdHJhdGVneSB9IGZyb20gJy4uL3ZpZXctc3RyYXRlZ2llcy92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld0NvbXBvbmVudCB9IGZyb20gJy4uL3ZpZXcvdmlldy5jb21wb25lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZ3JpZCcsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItZ3JpZFwiIChjbGljayk9XCJwYXJlbnRWaWV3LnNlbGVjdEl0ZW0oJGV2ZW50LCBwYW5lLCBzbGlkZXIubm90UGFubmluZylcIj5cclxuICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItaW5kZW50XCIgW3N0eWxlLndpZHRoLiVdPVwiMTAwIC8gNyAqIHBhbmUuaW5kZW50XCI+PC9kaXY+XHJcbiAgPGRpdiAqbmdGb3I9XCJsZXQgdmFsdWUgb2YgcGFuZS52YWx1ZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXg7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLWNlbGxcIj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIFthdHRyLmRhdGEtaW5kZXhdPVwiaVwiIFtjbGFzc109XCJtYWtlSXRlbUNsYXNzZXMoaSwgcGFuZSlcIiBbZGlzYWJsZWRdPVwiaXNEaXNhYmxlZChpLCBwYW5lKVwiPlxyXG4gICAgICB7e2l0ZW1MYWJlbHNbaV0gfHwgKHZhbHVlIHwgZGF0ZTppdGVtRm9ybWF0KX19XHJcbiAgICA8L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBHcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBwYW5lOiBQYW5lO1xyXG5cclxuICBASW5wdXQoKSBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgQElucHV0KCkgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKSByZWFkb25seSBfaG9zdENsYXNzID0gJ3NrbS1kYXRlcGlja2VyLWNvbnRlbnQnO1xyXG5cclxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBzbGlkZXI6IFNsaWRlckNvbXBvbmVudCxcclxuICAgICAgICAgICAgICByZWFkb25seSBwYXJlbnRWaWV3OiBWaWV3Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnaXRlbUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLml0ZW1MYWJlbHMgPSB0aGlzLml0ZW1MYWJlbHMgfHwgW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtYWtlSXRlbUNsYXNzZXMoaW5kZXg6IG51bWJlciwgcGFuZTogUGFuZSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLnZpZXdTdHJhdGVneS5pdGVtQ2xhc3MsXHJcbiAgICAgICdza20tZGF0ZXBpY2tlci1pdGVtJyxcclxuICAgICAgKHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5jdXJyZW50VGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1jdXJyZW50JyA6ICcnLFxyXG4gICAgICAocGFuZS52YWx1ZXNbaW5kZXhdID09PSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1zZWxlY3RlZCcgOiAnJyxcclxuICAgIF0uam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgaXNEaXNhYmxlZChpbmRleDogbnVtYmVyLCBwYW5lOiBQYW5lKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKHBhbmUudmFsdWVzW2luZGV4XSA8IHRoaXMubWluVGltZXN0YW1wKSB8fCAocGFuZS52YWx1ZXNbaW5kZXhdID4gdGhpcy5tYXhUaW1lc3RhbXApO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG59XHJcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVmlld1N0cmF0ZWd5IH0gZnJvbSAnLi92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld01vZGUgfSBmcm9tICcuLi9kYXRlcGlja2VyL3ZpZXctbW9kZSc7XHJcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi9wYW5lJztcclxuaW1wb3J0IHsgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IHN0YXJ0T2ZNb250aCB9IGZyb20gJy4uL3V0aWwvaGVscGVycyc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tza21EYXlzU3RyYXRlZ3ldJyxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBWaWV3U3RyYXRlZ3ksIHVzZUV4aXN0aW5nOiBEYXlzU3RyYXRlZ3lEaXJlY3RpdmV9LFxyXG4gIF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBEYXlzU3RyYXRlZ3lEaXJlY3RpdmUgZXh0ZW5kcyBWaWV3U3RyYXRlZ3kge1xyXG4gIHJlYWRvbmx5IHZpZXdNb2RlID0gVmlld01vZGUuRGF5cztcclxuICByZWFkb25seSBpdGVtQ2xhc3MgPSAnc2ttLWRhdGVwaWNrZXItZGF5JztcclxuXHJcbiAgbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aW1lc3RhbXA7XHJcbiAgfVxyXG5cclxuICBtYWtlSW5pdFBhbmVzU2VlZCh0aW1lc3RhbXA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gc3RhcnRPZk1vbnRoKHRpbWVzdGFtcCkudmFsdWVPZigpO1xyXG4gIH1cclxuXHJcbiAgbWFrZVBhbmUodGltZXN0YW1wOiBudW1iZXIsIGFkZDogbnVtYmVyLCBiYXNlT3JkZXI6IG51bWJlciwgd2Vla1N0YXJ0OiBXZWVrRGF5KTogUGFuZSB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKTtcclxuICAgIGRhdGUuc2V0TW9udGgoYWRkICsgZGF0ZS5nZXRNb250aCgpKTtcclxuICAgIGNvbnN0IGZpcnN0RGF5ID0gZGF0ZS5nZXREYXkoKTtcclxuXHJcbiAgICBkYXRlLnNldE1vbnRoKDEgKyBkYXRlLmdldE1vbnRoKCkpO1xyXG4gICAgZGF0ZS5zZXREYXRlKDApO1xyXG4gICAgY29uc3QgbW9udGhMZW5ndGggPSBkYXRlLmdldERhdGUoKTtcclxuXHJcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG1vbnRoTGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFsdWVzLnB1c2goZGF0ZS5zZXREYXRlKGkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvcmRlcjogYmFzZU9yZGVyICsgYWRkLFxyXG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcclxuICAgICAgaW5kZW50OiAoZmlyc3REYXkgLSB3ZWVrU3RhcnQgKyA3KSAlIDcgfHwgNywgLy8gRGVmYXVsdGluZyB0byBmdWxsIHdlZWsgbWFrZXMgZm9yIG1vcmUgYSBiYWxhbmNlZCBjZWxscyBsYXlvdXRcclxuICAgIH07XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBzdGFydE9mWWVhciB9IGZyb20gJy4uL3V0aWwvaGVscGVycyc7XHJcbmltcG9ydCB7IFZpZXdTdHJhdGVneSB9IGZyb20gJy4vdmlldy1zdHJhdGVneSc7XHJcbmltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3NrbU1vbnRoc1N0cmF0ZWd5XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogVmlld1N0cmF0ZWd5LCB1c2VFeGlzdGluZzogTW9udGhzU3RyYXRlZ3lEaXJlY3RpdmV9LFxyXG4gIF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNb250aHNTdHJhdGVneURpcmVjdGl2ZSBleHRlbmRzIFZpZXdTdHJhdGVneSB7XHJcbiAgcmVhZG9ubHkgdmlld01vZGUgPSBWaWV3TW9kZS5Nb250aHM7XHJcbiAgcmVhZG9ubHkgaXRlbUNsYXNzID0gJ3NrbS1kYXRlcGlja2VyLW1vbnRoJztcclxuXHJcbiAgbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApLnNldERhdGUoMSk7XHJcbiAgfVxyXG5cclxuICBtYWtlSW5pdFBhbmVzU2VlZCh0aW1lc3RhbXA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gc3RhcnRPZlllYXIodGltZXN0YW1wKS52YWx1ZU9mKCk7XHJcbiAgfVxyXG5cclxuICBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgZGF0ZS5zZXRGdWxsWWVhcihhZGQgKyBkYXRlLmdldEZ1bGxZZWFyKCkpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKGRhdGUuc2V0TW9udGgoaSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9yZGVyOiBiYXNlT3JkZXIgKyBhZGQsXHJcbiAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IHN0YXJ0T2ZZZWFyIH0gZnJvbSAnLi4vdXRpbC9oZWxwZXJzJztcclxuaW1wb3J0IHsgVmlld1N0cmF0ZWd5IH0gZnJvbSAnLi92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld01vZGUgfSBmcm9tICcuLi9kYXRlcGlja2VyL3ZpZXctbW9kZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbc2ttWWVhcnNTdHJhdGVneV0nLFxyXG4gIHByb3ZpZGVyczogW1xyXG4gICAge3Byb3ZpZGU6IFZpZXdTdHJhdGVneSwgdXNlRXhpc3Rpbmc6IFllYXJzU3RyYXRlZ3lEaXJlY3RpdmV9LFxyXG4gIF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBZZWFyc1N0cmF0ZWd5RGlyZWN0aXZlIGV4dGVuZHMgVmlld1N0cmF0ZWd5IHtcclxuICByZWFkb25seSB2aWV3TW9kZSA9IFZpZXdNb2RlLlllYXJzO1xyXG4gIHJlYWRvbmx5IGl0ZW1DbGFzcyA9ICdza20tZGF0ZXBpY2tlci15ZWFyJztcclxuXHJcbiAgbm9ybWFsaXplVGltZXN0YW1wKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXApLnNldE1vbnRoKDAsIDEpO1xyXG4gIH1cclxuXHJcbiAgbWFrZUluaXRQYW5lc1NlZWQodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcbiAgICBjb25zdCBvcmlnaW4gPSBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICBjb25zdCBhZGp1c3RlZCA9IG9yaWdpbiAtIChvcmlnaW4gJSAyMCk7XHJcbiAgICByZXR1cm4gc3RhcnRPZlllYXIoZGF0ZSkuc2V0RnVsbFllYXIoYWRqdXN0ZWQpO1xyXG4gIH1cclxuXHJcbiAgbWFrZVBhbmUodGltZXN0YW1wOiBudW1iZXIsIGFkZDogbnVtYmVyLCBiYXNlT3JkZXI6IG51bWJlciwgd2Vla1N0YXJ0OiBXZWVrRGF5KTogUGFuZSB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKTtcclxuICAgIGNvbnN0IG9yaWdpbiA9IGFkZCAqIDIwICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XHJcbiAgICAgIHZhbHVlcy5wdXNoKGRhdGUuc2V0RnVsbFllYXIob3JpZ2luICsgaSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9yZGVyOiBiYXNlT3JkZXIgKyBhZGQsXHJcbiAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IERhdGVwaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuL3NsaWRlci9zbGlkZXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgVmlld0NvbXBvbmVudCB9IGZyb20gJy4vdmlldy92aWV3LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEdyaWRDb21wb25lbnQgfSBmcm9tICcuL2dyaWQvZ3JpZC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBEYXlzU3RyYXRlZ3lEaXJlY3RpdmUgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ2llcy9kYXlzLXN0cmF0ZWd5LmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IE1vbnRoc1N0cmF0ZWd5RGlyZWN0aXZlIH0gZnJvbSAnLi92aWV3LXN0cmF0ZWdpZXMvbW9udGhzLXN0cmF0ZWd5LmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IFllYXJzU3RyYXRlZ3lEaXJlY3RpdmUgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ2llcy95ZWFycy1zdHJhdGVneS5kaXJlY3RpdmUnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbXHJcbiAgICBDb21tb25Nb2R1bGUsXHJcbiAgXSxcclxuICBkZWNsYXJhdGlvbnM6IFtcclxuICAgIERhdGVwaWNrZXJDb21wb25lbnQsXHJcbiAgICBWaWV3Q29tcG9uZW50LFxyXG4gICAgU2xpZGVyQ29tcG9uZW50LFxyXG4gICAgR3JpZENvbXBvbmVudCxcclxuICAgIERheXNTdHJhdGVneURpcmVjdGl2ZSxcclxuICAgIE1vbnRoc1N0cmF0ZWd5RGlyZWN0aXZlLFxyXG4gICAgWWVhcnNTdHJhdGVneURpcmVjdGl2ZSxcclxuICBdLFxyXG4gIGV4cG9ydHM6IFtcclxuICAgIERhdGVwaWNrZXJDb21wb25lbnQsXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIERhdGVwaWNrZXJNb2R1bGUge1xyXG59XHJcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJXZWVrRGF5IiwiZ2V0TG9jYWxlRGF5TmFtZXMiLCJGb3JtU3R5bGUiLCJUcmFuc2xhdGlvbldpZHRoIiwiQ29tcG9uZW50IiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJOR19WQUxVRV9BQ0NFU1NPUiIsIkNoYW5nZURldGVjdG9yUmVmIiwiSW5qZWN0IiwiTE9DQUxFX0lEIiwiSW5wdXQiLCJPdXRwdXQiLCJ0cmlnZ2VyIiwic3RhdGUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJhbmltYXRlIiwiU3ViamVjdCIsImZyb21FdmVudCIsInRha2VVbnRpbCIsIkVsZW1lbnRSZWYiLCJOZ1pvbmUiLCJIb3N0QmluZGluZyIsInRzbGliXzEuX19leHRlbmRzIiwiRGlyZWN0aXZlIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUJBQTRCLElBQVU7UUFDcEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUMvQjs7Ozs7QUFFRCx3QkFBMkIs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