import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Input, LOCALE_ID, Output, ElementRef, NgZone, HostBinding, Directive, NgModule } from '@angular/core';
import { FormStyle, getLocaleDayNames, TranslationWidth, WeekDay, CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { fromEvent, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { __extends } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function isValidDate(date) {
    return !isNaN(date.getTime());
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfDay(date) {
    var /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    return d;
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfMonth(date) {
    var /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    d.setDate(1);
    return d;
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfYear(date) {
    var /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    d.setMonth(0, 1);
    return d;
}
/**
 * @param {?} panRatio
 * @return {?}
 */
function createEaseOut(panRatio) {
    var /** @type {?} */ a = (panRatio - 2) / Math.pow(panRatio, 3);
    var /** @type {?} */ b = (3 - 2 * panRatio) / Math.pow(panRatio, 2);
    return function easeOut(x) {
        return (x >= panRatio) ? 1 : ((a * x + b) * x + 1) * x;
    };
}
/**
 * @return {?}
 */
function noop() {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
var ViewMode = {
    Days: 'days',
    Months: 'months',
    Years: 'years',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DatepickerComponent = /** @class */ (function () {
    function DatepickerComponent(cd, locale) {
        this.cd = cd;
        this.locale = locale;
        this.dateChange = new EventEmitter();
        this.dayFormat = 'd';
        this.monthFormat = 'MMM';
        this.yearFormat = 'y';
        this.headingFormat = 'MMMM y';
        this.weekStart = WeekDay.Monday;
        this.view = ViewMode.Days;
        this.ViewMode = ViewMode;
        this.onChange = noop;
        this.onTouched = noop;
    }
    Object.defineProperty(DatepickerComponent.prototype, "date", {
        set: /**
         * @param {?} dirtyDate
         * @return {?}
         */
        function (dirtyDate) {
            if (dirtyDate == null) {
                this.selectedTimestamp = undefined;
                return;
            }
            var /** @type {?} */ date = startOfDay(dirtyDate);
            if (date.getTime() !== this.selectedTimestamp) {
                this.selectedTimestamp = isValidDate(date) ? date.getTime() : undefined;
                if (typeof this.selectedTimestamp !== 'undefined') {
                    this.initialTimestamp = this.selectedTimestamp;
                    this.view = ViewMode.Days;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatepickerComponent.prototype, "min", {
        set: /**
         * @param {?} dirtyDate
         * @return {?}
         */
        function (dirtyDate) {
            var /** @type {?} */ date = startOfDay(dirtyDate);
            this.minTimestamp = isValidDate(date) ? date.valueOf() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatepickerComponent.prototype, "max", {
        set: /**
         * @param {?} dirtyDate
         * @return {?}
         */
        function (dirtyDate) {
            var /** @type {?} */ date = startOfDay(dirtyDate);
            this.maxTimestamp = isValidDate(date) ? date.valueOf() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    DatepickerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('weekDayLabels' in changes) {
            this.weekDayLabels = this.weekDayLabels || getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        }
    };
    /**
     * @return {?}
     */
    DatepickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.currentTimestamp = startOfDay(new Date()).getTime();
        this.initialTimestamp = this.selectedTimestamp || this.currentTimestamp;
        this.weekDayLabels = this.weekDayLabels || getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    DatepickerComponent.prototype.selectDay = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        console.log(timestamp);
        this.selectedTimestamp = timestamp;
        var /** @type {?} */ date = (typeof timestamp !== 'undefined') ? new Date(timestamp) : undefined;
        this.onChange(date);
        this.dateChange.emit(date);
    };
    /**
     * @param {?} timestamp
     * @param {?} view
     * @param {?} direction
     * @return {?}
     */
    DatepickerComponent.prototype.switchView = /**
     * @param {?} timestamp
     * @param {?} view
     * @param {?} direction
     * @return {?}
     */
    function (timestamp, view, direction) {
        var _this = this;
        this.zoomDirection = direction;
        setTimeout(function () {
            _this.initialTimestamp = timestamp;
            _this.view = view;
            _this.cd.markForCheck();
        });
    };
    // ControlValueAccessor implementation
    /**
     * @param {?} obj
     * @return {?}
     */
    DatepickerComponent.prototype.writeValue = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        this.date = obj;
        this.cd.markForCheck();
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    DatepickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    DatepickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
        // TODO implement
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    DatepickerComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        // TODO implement
        this.cd.markForCheck();
    };
    DatepickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'skm-datepicker',
                    template: "<div class=\"skm-datepicker\" [ngSwitch]=\"view\">\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Days\"\n    skmDaysStrategy\n    class=\"skm-datepicker-view skm-datepicker-days-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [deselectEnabled]=\"deselectEnabled\"\n\n    [headingFormat]=\"headingFormat\"\n    [weekStart]=\"weekStart\"\n    [weekDayLabels]=\"weekDayLabels\"\n    [itemFormat]=\"dayFormat\"\n    [itemLabels]=\"dayLabels\"\n\n    (headerClick)=\"switchView($event, ViewMode.Months, 'out')\"\n    (itemChange)=\"selectDay($event)\"\n  ></skm-view>\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Months\"\n    skmMonthsStrategy\n    class=\"skm-datepicker-view skm-datepicker-months-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [headingFormat]=\"yearFormat\"\n    [itemFormat]=\"monthFormat\"\n    [itemLabels]=\"monthLabels\"\n\n    (headerClick)=\"switchView($event, ViewMode.Years, 'out')\"\n    (itemChange)=\"switchView($event, ViewMode.Days, 'in')\"\n  ></skm-view>\n  <skm-view\n    *ngSwitchCase=\"ViewMode.Years\"\n    skmYearsStrategy\n    class=\"skm-datepicker-view skm-datepicker-years-view\"\n    [zoomDirection]=\"zoomDirection\"\n    [initialTimestamp]=\"initialTimestamp\"\n\n    [currentTimestamp]=\"currentTimestamp\"\n    [selectedTimestamp]=\"selectedTimestamp\"\n    [minTimestamp]=\"minTimestamp\"\n    [maxTimestamp]=\"maxTimestamp\"\n\n    [headingFormat]=\"yearFormat\"\n    [itemFormat]=\"yearFormat\"\n\n    (itemChange)=\"switchView($event, ViewMode.Months, 'in')\"\n  ></skm-view>\n</div>\n",
                    styles: [".skm-datepicker{position:relative;overflow:hidden}.skm-datepicker-view{display:block;position:absolute;height:100%;width:100%}", "button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: DatepickerComponent, multi: true },
                    ],
                },] },
    ];
    /** @nocollapse */
    DatepickerComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef, },
        { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
    ]; };
    DatepickerComponent.propDecorators = {
        "date": [{ type: Input },],
        "dateChange": [{ type: Output },],
        "min": [{ type: Input },],
        "max": [{ type: Input },],
        "deselectEnabled": [{ type: Input },],
        "dayFormat": [{ type: Input },],
        "monthFormat": [{ type: Input },],
        "yearFormat": [{ type: Input },],
        "headingFormat": [{ type: Input },],
        "weekStart": [{ type: Input },],
        "dayLabels": [{ type: Input },],
        "weekDayLabels": [{ type: Input },],
        "monthLabels": [{ type: Input },],
        "view": [{ type: Input },],
    };
    return DatepickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?=} timing
 * @return {?}
 */
function slide(timing) {
    if (timing === void 0) { timing = 150; }
    return trigger('slide', [
        state('panning', style({
            transform: 'translateX({{x}}%)',
        }), { params: { x: 0 } }),
        transition('* => 1', animate(timing, style({
            transform: 'translateX(-100%)',
        }))),
        transition('* => -1', animate(timing, style({
            transform: 'translateX(100%)',
        }))),
        transition('panning => idle', animate(timing)),
    ]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SliderComponent = /** @class */ (function () {
    function SliderComponent(hostRef, cd, zone) {
        this.hostRef = hostRef;
        this.cd = cd;
        this.zone = zone;
        this.prevDisabled = false;
        this.nextDisabled = false;
        this.slideDone = new EventEmitter();
        this.notPanning = true;
        this.wrapperWidth = 1;
        this.panOffset = 0;
        this.ngUnsubscribe$ = new Subject();
        this.easeOut = createEaseOut(1.3);
        this.cd.detach();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    SliderComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.changeSlideTrigger();
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            var /** @type {?} */ host = _this.hostRef.nativeElement;
            fromEvent(host, 'mousedown').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.startPress(); });
            if ('Hammer' in window) {
                var /** @type {?} */ hammer = new Hammer(host);
                fromEvent(hammer, 'panstart').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.startPan(); });
                fromEvent(hammer, 'panmove').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function (e) { return _this.pan(e); });
                fromEvent(hammer, 'panend pancancel').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.endPan(); });
                fromEvent(hammer, 'swiperight').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.swipe(-1); });
                fromEvent(hammer, 'swipeleft').pipe(takeUntil(_this.ngUnsubscribe$)).subscribe(function () { return _this.swipe(1); });
            }
        });
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SliderComponent.prototype.done = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === this.lastDoneEventToState) {
            // workaround for https://github.com/angular/angular/issues/24084
            return;
        }
        this.lastDoneEventToState = event.toState;
        if (/** @type {?} */ (typeof event.toState) === 'number') {
            this.slideDone.emit(/** @type {?} */ (event.toState));
        }
    };
    /**
     * @param {?} direction
     * @return {?}
     */
    SliderComponent.prototype.slide = /**
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        var _this = this;
        this.changeSlideTrigger();
        setTimeout(function () { return _this.changeSlideTrigger(/** @type {?} */ (direction)); });
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.startPress = /**
     * @return {?}
     */
    function () {
        this.notPanning = true;
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.startPan = /**
     * @return {?}
     */
    function () {
        this.notPanning = false;
        this.wrapperWidth = this.hostRef.nativeElement.offsetWidth;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SliderComponent.prototype.pan = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ multiplier = (event.deltaX > 0 && this.prevDisabled || event.deltaX < 0 && this.nextDisabled) ? 0.1 : 1;
        var /** @type {?} */ absOffset = Math.abs(event.deltaX / this.wrapperWidth);
        this.panOffset = Math.sign(event.deltaX) * this.easeOut(absOffset);
        this.changeSlideTrigger('panning', this.panOffset * multiplier);
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.endPan = /**
     * @return {?}
     */
    function () {
        if (Math.abs(this.panOffset) > 0.5) {
            this.changeSlideTrigger(/** @type {?} */ (-Math.sign(this.panOffset)));
        }
        else if (this.slideTrigger.value === 'panning') {
            this.changeSlideTrigger();
        }
    };
    /**
     * @param {?} direction
     * @return {?}
     */
    SliderComponent.prototype.swipe = /**
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        this.changeSlideTrigger(/** @type {?} */ (direction));
    };
    /**
     * @param {?=} value
     * @param {?=} offset
     * @return {?}
     */
    SliderComponent.prototype.changeSlideTrigger = /**
     * @param {?=} value
     * @param {?=} offset
     * @return {?}
     */
    function (value, offset) {
        if (value === void 0) { value = 'idle'; }
        if (offset === void 0) { offset = 0; }
        this.slideTrigger = {
            value: (value === -1 && this.prevDisabled || value === 1 && this.nextDisabled) ? 'idle' : value,
            params: { x: offset * 100 },
        };
        this.cd.detectChanges();
    };
    SliderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'skm-slider',
                    template: "<div class=\"skm-datepicker-slider\" [@slide]=\"slideTrigger\" (@slide.done)=\"done($event)\">\n  <ng-content></ng-content>\n</div>\n<button type=\"button\" class=\"skm-datepicker-pagination skm-prev\" (click)=\"slide(-1)\" [disabled]=\"prevDisabled\">&lsaquo;</button>\n<button type=\"button\" class=\"skm-datepicker-pagination skm-next\" (click)=\"slide(1)\" [disabled]=\"nextDisabled\">&rsaquo;</button>\n",
                    styles: [":host{display:block;position:relative;height:100%}.skm-datepicker-slider{display:flex;position:relative;left:-100%;height:100%}.skm-datepicker-pagination{position:absolute;top:0}.skm-datepicker-pagination.skm-prev{left:0}.skm-datepicker-pagination.skm-next{right:0}", "button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                    animations: [slide()],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    SliderComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: NgZone, },
    ]; };
    SliderComponent.propDecorators = {
        "prevDisabled": [{ type: Input },],
        "nextDisabled": [{ type: Input },],
        "slideDone": [{ type: Output },],
    };
    return SliderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ biggerStyle = style({
    transform: 'scale(0.8)',
    opacity: 0,
});
var /** @type {?} */ smallerStyle = style({
    transform: 'scale(1.3)',
    opacity: 0,
});
/**
 * @param {?=} timing
 * @return {?}
 */
function zoom(timing) {
    if (timing === void 0) { timing = 175; }
    return trigger('zoom', [
        transition('void => in', [
            biggerStyle,
            animate(timing),
        ]),
        transition('void => out', [
            smallerStyle,
            animate(timing),
        ]),
        transition('in => void', [
            animate(timing, smallerStyle),
        ]),
        transition('out => void', [
            animate(timing, biggerStyle),
        ]),
    ]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
ViewStrategy = /** @class */ (function () {
    function ViewStrategy() {
    }
    return ViewStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ViewComponent = /** @class */ (function () {
    function ViewComponent(viewStrategy) {
        this.viewStrategy = viewStrategy;
        this.itemChange = new EventEmitter();
        this.headerClick = new EventEmitter();
        this.ViewMode = ViewMode;
        this.prevDisabled = false;
        this.nextDisabled = false;
        this.regularTimestampFields = ['currentTimestamp', 'selectedTimestamp', 'minTimestamp', 'maxTimestamp'];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ViewComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (this.viewStrategy.viewMode !== ViewMode.Days) {
            this.regularTimestampFields.forEach(function (field) {
                if (field in changes) {
                    _this[field] = _this[field] ? _this.viewStrategy.normalizeTimestamp(_this[field]) : undefined;
                }
            });
        }
        if ('initialTimestamp' in changes) {
            // Must be called after normalization of other timestamps for proper behavior of min-max range
            this.initPanes(this.initialTimestamp);
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    ViewComponent.prototype.trackIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index;
    };
    /**
     * @param {?} notPanning
     * @return {?}
     */
    ViewComponent.prototype.clickHeader = /**
     * @param {?} notPanning
     * @return {?}
     */
    function (notPanning) {
        if (notPanning) {
            this.headerClick.emit(this.panes[this.visiblePaneIndex].values[0]);
        }
    };
    /**
     * @param {?} event
     * @param {?} pane
     * @param {?} notPanning
     * @return {?}
     */
    ViewComponent.prototype.selectItem = /**
     * @param {?} event
     * @param {?} pane
     * @param {?} notPanning
     * @return {?}
     */
    function (event, pane, notPanning) {
        if (notPanning) {
            var /** @type {?} */ button = /** @type {?} */ (event.target);
            var /** @type {?} */ index = button.dataset["index"];
            if (this.deselectEnabled && pane.values[index] === this.selectedTimestamp) {
                this.itemChange.emit(undefined);
            }
            else {
                this.itemChange.emit(pane.values[index]);
            }
        }
    };
    /**
     * @param {?} direction
     * @return {?}
     */
    ViewComponent.prototype.switchPanes = /**
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        this.visiblePaneIndex = (3 + this.visiblePaneIndex + direction) % 3;
        var /** @type {?} */ index = (3 + this.visiblePaneIndex + direction) % 3;
        var /** @type {?} */ pane = this.panes[index];
        this.panes[index] = this.viewStrategy.makePane(pane.values[0], 3 * direction, pane.order, this.weekStart);
        this.updateDisabledStatus((3 + this.visiblePaneIndex - 1) % 3, (3 + this.visiblePaneIndex + 1) % 3);
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    ViewComponent.prototype.initPanes = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        var _this = this;
        var /** @type {?} */ seed = this.viewStrategy.makeInitPanesSeed(timestamp);
        this.panes = [-1, 0, 1].map(function (i) { return _this.viewStrategy.makePane(seed, i, 0, _this.weekStart); });
        this.visiblePaneIndex = 1;
        this.updateDisabledStatus(0, 2);
    };
    /**
     * @param {?} prevIndex
     * @param {?} nextIndex
     * @return {?}
     */
    ViewComponent.prototype.updateDisabledStatus = /**
     * @param {?} prevIndex
     * @param {?} nextIndex
     * @return {?}
     */
    function (prevIndex, nextIndex) {
        this.prevDisabled = this.panes[prevIndex].values[this.panes[prevIndex].values.length - 1] < this.minTimestamp;
        this.nextDisabled = this.panes[nextIndex].values[0] > this.maxTimestamp;
    };
    ViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'skm-view',
                    template: "<skm-slider [prevDisabled]=\"prevDisabled\" [nextDisabled]=\"nextDisabled\" (slideDone)=\"switchPanes($event)\" #slider>\n  <div class=\"skm-datepicker-pane\" *ngFor=\"let pane of panes; trackBy: trackIndex\" [style.order]=\"pane.order\">\n    <button type=\"button\" class=\"skm-datepicker-header\"\n            (click)=\"clickHeader(slider.notPanning)\" [disabled]=\"viewStrategy.viewMode === ViewMode.Years\">\n      {{pane.values[0] | date:headingFormat}}\n      <ng-container *ngIf=\"viewStrategy.viewMode === ViewMode.Years\">\n        &ndash; {{pane.values[19] | date:headingFormat}}\n      </ng-container>\n    </button>\n    <div class=\"skm-datepicker-week\" *ngIf=\"viewStrategy.viewMode === ViewMode.Days\">\n      <div class=\"skm-datepicker-weekday\" *ngFor=\"let label of weekDayLabels | slice:weekStart:7\">{{label}}</div>\n      <div class=\"skm-datepicker-weekday\" *ngFor=\"let label of weekDayLabels | slice:0:weekStart\">{{label}}</div>\n    </div>\n    <skm-grid\n      [pane]=\"pane\"\n      [currentTimestamp]=\"currentTimestamp\"\n      [selectedTimestamp]=\"selectedTimestamp\"\n      [minTimestamp]=\"minTimestamp\"\n      [maxTimestamp]=\"maxTimestamp\"\n      [itemFormat]=\"itemFormat\"\n      [itemLabels]=\"itemLabels\"\n    ></skm-grid>\n  </div>\n</skm-slider>\n",
                    styles: ["button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                    animations: [zoom()],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    ViewComponent.ctorParameters = function () { return [
        { type: ViewStrategy, },
    ]; };
    ViewComponent.propDecorators = {
        "zoomDirection": [{ type: Input }, { type: HostBinding, args: ['@zoom',] },],
        "initialTimestamp": [{ type: Input },],
        "currentTimestamp": [{ type: Input },],
        "selectedTimestamp": [{ type: Input },],
        "minTimestamp": [{ type: Input },],
        "maxTimestamp": [{ type: Input },],
        "deselectEnabled": [{ type: Input },],
        "headingFormat": [{ type: Input },],
        "weekStart": [{ type: Input },],
        "weekDayLabels": [{ type: Input },],
        "itemFormat": [{ type: Input },],
        "itemLabels": [{ type: Input },],
        "itemChange": [{ type: Output },],
        "headerClick": [{ type: Output },],
    };
    return ViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GridComponent = /** @class */ (function () {
    function GridComponent(slider, parentView, viewStrategy) {
        this.slider = slider;
        this.parentView = parentView;
        this.viewStrategy = viewStrategy;
        this.itemLabels = [];
        this._hostClass = 'skm-datepicker-content';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    GridComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('itemLabels' in changes) {
            this.itemLabels = this.itemLabels || [];
        }
    };
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    GridComponent.prototype.makeItemClasses = /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    function (index, pane) {
        return [
            this.viewStrategy.itemClass,
            'skm-datepicker-item',
            (pane.values[index] === this.currentTimestamp) ? 'skm-datepicker-current' : '',
            (pane.values[index] === this.selectedTimestamp) ? 'skm-datepicker-selected' : '',
        ].join(' ');
    };
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    GridComponent.prototype.isDisabled = /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    function (index, pane) {
        return (pane.values[index] < this.minTimestamp) || (pane.values[index] > this.maxTimestamp);
    };
    /**
     * @param {?} index
     * @return {?}
     */
    GridComponent.prototype.trackIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index;
    };
    GridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'skm-grid',
                    template: "<div class=\"skm-datepicker-grid\" (click)=\"parentView.selectItem($event, pane, slider.notPanning)\">\n  <div class=\"skm-datepicker-indent\" [style.width.%]=\"100 / 7 * pane.indent\"></div>\n  <div *ngFor=\"let value of pane.values; trackBy: trackIndex; let i = index\" class=\"skm-datepicker-cell\">\n    <button type=\"button\" [attr.data-index]=\"i\" [class]=\"makeItemClasses(i, pane)\" [disabled]=\"isDisabled(i, pane)\">\n      {{itemLabels[i] || (value | date:itemFormat)}}\n    </button>\n  </div>\n</div>\n",
                    styles: ["button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}"],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    GridComponent.ctorParameters = function () { return [
        { type: SliderComponent, },
        { type: ViewComponent, },
        { type: ViewStrategy, },
    ]; };
    GridComponent.propDecorators = {
        "pane": [{ type: Input },],
        "currentTimestamp": [{ type: Input },],
        "selectedTimestamp": [{ type: Input },],
        "minTimestamp": [{ type: Input },],
        "maxTimestamp": [{ type: Input },],
        "itemFormat": [{ type: Input },],
        "itemLabels": [{ type: Input },],
        "_hostClass": [{ type: HostBinding, args: ['class',] },],
    };
    return GridComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DaysStrategyDirective = /** @class */ (function (_super) {
    __extends(DaysStrategyDirective, _super);
    function DaysStrategyDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.viewMode = ViewMode.Days;
        _this.itemClass = 'skm-datepicker-day';
        return _this;
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    DaysStrategyDirective.prototype.normalizeTimestamp = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return timestamp;
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    DaysStrategyDirective.prototype.makeInitPanesSeed = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return startOfMonth(timestamp).valueOf();
    };
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    DaysStrategyDirective.prototype.makePane = /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    function (timestamp, add, baseOrder, weekStart) {
        var /** @type {?} */ date = new Date(timestamp);
        date.setMonth(add + date.getMonth());
        var /** @type {?} */ firstDay = date.getDay();
        date.setMonth(1 + date.getMonth());
        date.setDate(0);
        var /** @type {?} */ monthLength = date.getDate();
        var /** @type {?} */ values = [];
        for (var /** @type {?} */ i = 1; i <= monthLength; i++) {
            values.push(date.setDate(i));
        }
        return {
            order: baseOrder + add,
            values: values,
            indent: (firstDay - weekStart + 7) % 7 || 7,
        };
    };
    DaysStrategyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[skmDaysStrategy]',
                    providers: [
                        { provide: ViewStrategy, useExisting: DaysStrategyDirective },
                    ],
                },] },
    ];
    return DaysStrategyDirective;
}(ViewStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MonthsStrategyDirective = /** @class */ (function (_super) {
    __extends(MonthsStrategyDirective, _super);
    function MonthsStrategyDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.viewMode = ViewMode.Months;
        _this.itemClass = 'skm-datepicker-month';
        return _this;
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    MonthsStrategyDirective.prototype.normalizeTimestamp = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return new Date(timestamp).setDate(1);
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    MonthsStrategyDirective.prototype.makeInitPanesSeed = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return startOfYear(timestamp).valueOf();
    };
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    MonthsStrategyDirective.prototype.makePane = /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    function (timestamp, add, baseOrder, weekStart) {
        var /** @type {?} */ date = new Date(timestamp);
        date.setFullYear(add + date.getFullYear());
        var /** @type {?} */ values = [];
        for (var /** @type {?} */ i = 0; i < 12; i++) {
            values.push(date.setMonth(i));
        }
        return {
            order: baseOrder + add,
            values: values,
        };
    };
    MonthsStrategyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[skmMonthsStrategy]',
                    providers: [
                        { provide: ViewStrategy, useExisting: MonthsStrategyDirective },
                    ],
                },] },
    ];
    return MonthsStrategyDirective;
}(ViewStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var YearsStrategyDirective = /** @class */ (function (_super) {
    __extends(YearsStrategyDirective, _super);
    function YearsStrategyDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.viewMode = ViewMode.Years;
        _this.itemClass = 'skm-datepicker-year';
        return _this;
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    YearsStrategyDirective.prototype.normalizeTimestamp = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        return new Date(timestamp).setMonth(0, 1);
    };
    /**
     * @param {?} timestamp
     * @return {?}
     */
    YearsStrategyDirective.prototype.makeInitPanesSeed = /**
     * @param {?} timestamp
     * @return {?}
     */
    function (timestamp) {
        var /** @type {?} */ date = new Date(timestamp);
        var /** @type {?} */ origin = date.getFullYear();
        var /** @type {?} */ adjusted = origin - (origin % 20);
        return startOfYear(date).setFullYear(adjusted);
    };
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    YearsStrategyDirective.prototype.makePane = /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    function (timestamp, add, baseOrder, weekStart) {
        var /** @type {?} */ date = new Date(timestamp);
        var /** @type {?} */ origin = add * 20 + date.getFullYear();
        var /** @type {?} */ values = [];
        for (var /** @type {?} */ i = 0; i < 20; i++) {
            values.push(date.setFullYear(origin + i));
        }
        return {
            order: baseOrder + add,
            values: values,
        };
    };
    YearsStrategyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[skmYearsStrategy]',
                    providers: [
                        { provide: ViewStrategy, useExisting: YearsStrategyDirective },
                    ],
                },] },
    ];
    return YearsStrategyDirective;
}(ViewStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DatepickerModule = /** @class */ (function () {
    function DatepickerModule() {
    }
    DatepickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                    ],
                    declarations: [
                        DatepickerComponent,
                        ViewComponent,
                        SliderComponent,
                        GridComponent,
                        DaysStrategyDirective,
                        MonthsStrategyDirective,
                        YearsStrategyDirective,
                    ],
                    exports: [
                        DatepickerComponent,
                    ],
                },] },
    ];
    return DatepickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { DatepickerComponent, DatepickerModule, ViewMode, GridComponent as ɵf, slide as ɵe, SliderComponent as ɵd, zoom as ɵb, DaysStrategyDirective as ɵg, MonthsStrategyDirective as ɵh, ViewStrategy as ɵc, YearsStrategyDirective as ɵi, ViewComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2tpbW1lZC1kYXRlcGlja2VyLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3V0aWwvaGVscGVycy50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9kYXRlcGlja2VyL3ZpZXctbW9kZS50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9kYXRlcGlja2VyL2RhdGVwaWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3NsaWRlci9zbGlkZS5hbmltYXRpb24udHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdXRpbC96b29tLmFuaW1hdGlvbi50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneS50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi92aWV3L3ZpZXcuY29tcG9uZW50LnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy9tb250aHMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy95ZWFycy1zdHJhdGVneS5kaXJlY3RpdmUudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvZGF0ZXBpY2tlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcclxuICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZEYXkoZGF0ZTogRGF0ZSB8IG51bWJlcik6IERhdGUge1xyXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlIGFzIG51bWJlcik7XHJcbiAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aChkYXRlOiBEYXRlIHwgbnVtYmVyKTogRGF0ZSB7XHJcbiAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUgYXMgbnVtYmVyKTtcclxuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG4gIGQuc2V0RGF0ZSgxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZZZWFyKGRhdGU6IERhdGUgfCBudW1iZXIpOiBEYXRlIHtcclxuICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSBhcyBudW1iZXIpO1xyXG4gIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgZC5zZXRNb250aCgwLCAxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuLy8ga3Vkb3MgdG8gQG1pY2hlbDRuZ2VsMFxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWFzZU91dChwYW5SYXRpbzogbnVtYmVyKTogKHg6IG51bWJlcikgPT4gbnVtYmVyIHtcclxuICBjb25zdCBhID0gKHBhblJhdGlvIC0gMikgLyBwYW5SYXRpbyAqKiAzO1xyXG4gIGNvbnN0IGIgPSAoMyAtIDIgKiBwYW5SYXRpbykgLyBwYW5SYXRpbyAqKiAyO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gZWFzZU91dCh4OiBudW1iZXIpIHtcclxuICAgIHJldHVybiAoeCA+PSBwYW5SYXRpbykgPyAxIDogKChhICogeCArIGIpICogeCArIDEpICogeDtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcclxufVxyXG4iLCJleHBvcnQgZW51bSBWaWV3TW9kZSB7XHJcbiAgRGF5cyA9ICdkYXlzJyxcclxuICBNb250aHMgPSAnbW9udGhzJyxcclxuICBZZWFycyA9ICd5ZWFycycsXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBMT0NBTEVfSUQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRm9ybVN0eWxlLCBnZXRMb2NhbGVEYXlOYW1lcywgVHJhbnNsYXRpb25XaWR0aCwgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgaXNWYWxpZERhdGUsIG5vb3AsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4vdmlldy1tb2RlJztcclxuaW1wb3J0IHsgWm9vbURpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWwvem9vbS5hbmltYXRpb24nO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZGF0ZXBpY2tlcicsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXJcIiBbbmdTd2l0Y2hdPVwidmlld1wiPlxyXG4gIDxza20tdmlld1xyXG4gICAgKm5nU3dpdGNoQ2FzZT1cIlZpZXdNb2RlLkRheXNcIlxyXG4gICAgc2ttRGF5c1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3XCJcclxuICAgIFt6b29tRGlyZWN0aW9uXT1cInpvb21EaXJlY3Rpb25cIlxyXG4gICAgW2luaXRpYWxUaW1lc3RhbXBdPVwiaW5pdGlhbFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2N1cnJlbnRUaW1lc3RhbXBdPVwiY3VycmVudFRpbWVzdGFtcFwiXHJcbiAgICBbc2VsZWN0ZWRUaW1lc3RhbXBdPVwic2VsZWN0ZWRUaW1lc3RhbXBcIlxyXG4gICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgW21heFRpbWVzdGFtcF09XCJtYXhUaW1lc3RhbXBcIlxyXG5cclxuICAgIFtkZXNlbGVjdEVuYWJsZWRdPVwiZGVzZWxlY3RFbmFibGVkXCJcclxuXHJcbiAgICBbaGVhZGluZ0Zvcm1hdF09XCJoZWFkaW5nRm9ybWF0XCJcclxuICAgIFt3ZWVrU3RhcnRdPVwid2Vla1N0YXJ0XCJcclxuICAgIFt3ZWVrRGF5TGFiZWxzXT1cIndlZWtEYXlMYWJlbHNcIlxyXG4gICAgW2l0ZW1Gb3JtYXRdPVwiZGF5Rm9ybWF0XCJcclxuICAgIFtpdGVtTGFiZWxzXT1cImRheUxhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5Nb250aHMsICdvdXQnKVwiXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzZWxlY3REYXkoJGV2ZW50KVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuTW9udGhzXCJcclxuICAgIHNrbU1vbnRoc1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItbW9udGhzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJtb250aEZvcm1hdFwiXHJcbiAgICBbaXRlbUxhYmVsc109XCJtb250aExhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5ZZWFycywgJ291dCcpXCJcclxuICAgIChpdGVtQ2hhbmdlKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5EYXlzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuWWVhcnNcIlxyXG4gICAgc2ttWWVhcnNTdHJhdGVneVxyXG4gICAgY2xhc3M9XCJza20tZGF0ZXBpY2tlci12aWV3IHNrbS1kYXRlcGlja2VyLXllYXJzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJ5ZWFyRm9ybWF0XCJcclxuXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzd2l0Y2hWaWV3KCRldmVudCwgVmlld01vZGUuTW9udGhzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2Auc2ttLWRhdGVwaWNrZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci12aWV3e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX1gLCBgYnV0dG9ue2Rpc3BsYXk6YmxvY2s7Y29sb3I6aW5oZXJpdH1idXR0b246bm90KFtkaXNhYmxlZF0pe2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF17cG9pbnRlci1ldmVudHM6bm9uZX0uc2ttLWRhdGVwaWNrZXItcGFuZXtmbGV4LXNocmluazowO3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtvdmVyZmxvdzpoaWRkZW59LnNrbS1kYXRlcGlja2VyLXdlZWt7ZGlzcGxheTpmbGV4fS5za20tZGF0ZXBpY2tlci13ZWVrZGF5e3dpZHRoOjE0LjI4NTcxJX0uc2ttLWRhdGVwaWNrZXItY29udGVudHtmbGV4OjEgMCAwO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LnNrbS1kYXRlcGlja2VyLWdyaWR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXA7YWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLWluZGVudHtoZWlnaHQ6MTYuNjY2NjclfS5za20tZGF0ZXBpY2tlci1jZWxse2Rpc3BsYXk6ZmxleH06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1kYXlzLXZpZXcpIC5za20tZGF0ZXBpY2tlci1jZWxse3dpZHRoOjE0LjI4NTcxJTtoZWlnaHQ6MTYuNjY2NjclfTpob3N0LWNvbnRleHQoLnNrbS1kYXRlcGlja2VyLW1vbnRocy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDozMy4zMzMzMyU7aGVpZ2h0OjI1JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci15ZWFycy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoyMCU7aGVpZ2h0OjI1JX0uc2ttLWRhdGVwaWNrZXItaXRlbXtmbGV4OjE7cG9pbnRlci1ldmVudHM6YXV0b31gXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IERhdGVwaWNrZXJDb21wb25lbnQsIG11bHRpOiB0cnVlfSxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMsIE9uSW5pdCB7XHJcbiAgQElucHV0KCkgc2V0IGRhdGUoZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBpZiAoZGlydHlEYXRlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0ZSA9IHN0YXJ0T2ZEYXkoZGlydHlEYXRlKTtcclxuICAgIGlmIChkYXRlLmdldFRpbWUoKSAhPT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICB0aGlzLnNlbGVjdGVkVGltZXN0YW1wID0gaXNWYWxpZERhdGUoZGF0ZSkgPyBkYXRlLmdldFRpbWUoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGVkVGltZXN0YW1wICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFRpbWVzdGFtcCA9IHRoaXMuc2VsZWN0ZWRUaW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gVmlld01vZGUuRGF5cztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQE91dHB1dCgpIGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XHJcblxyXG4gIEBJbnB1dCgpIHNldCBtaW4oZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBkYXRlID0gc3RhcnRPZkRheShkaXJ0eURhdGUpO1xyXG4gICAgdGhpcy5taW5UaW1lc3RhbXAgPSBpc1ZhbGlkRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgc2V0IG1heChkaXJ0eURhdGU6IERhdGUgfCBudW1iZXIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZSk7XHJcbiAgICB0aGlzLm1heFRpbWVzdGFtcCA9IGlzVmFsaWREYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGRheUZvcm1hdCA9ICdkJztcclxuICBASW5wdXQoKSBtb250aEZvcm1hdCA9ICdNTU0nO1xyXG4gIEBJbnB1dCgpIHllYXJGb3JtYXQgPSAneSc7XHJcbiAgQElucHV0KCkgaGVhZGluZ0Zvcm1hdCA9ICdNTU1NIHknO1xyXG4gIEBJbnB1dCgpIHdlZWtTdGFydCA9IFdlZWtEYXkuTW9uZGF5O1xyXG5cclxuICBASW5wdXQoKSBkYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIHdlZWtEYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIG1vbnRoTGFiZWxzOiBzdHJpbmdbXTtcclxuXHJcbiAgQElucHV0KCkgdmlldyA9IFZpZXdNb2RlLkRheXM7XHJcblxyXG4gIGluaXRpYWxUaW1lc3RhbXA6IG51bWJlcjtcclxuICBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwcml2YXRlIG9uQ2hhbmdlOiAoZGF0ZTogRGF0ZSkgPT4gdm9pZCA9IG5vb3A7XHJcbiAgcHJpdmF0ZSBvblRvdWNoZWQ6ICgpID0+IHZvaWQgPSBub29wO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgbG9jYWxlOiBzdHJpbmcpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnd2Vla0RheUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLndlZWtEYXlMYWJlbHMgPSB0aGlzLndlZWtEYXlMYWJlbHMgfHwgZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50VGltZXN0YW1wID0gc3RhcnRPZkRheShuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wIHx8IHRoaXMuY3VycmVudFRpbWVzdGFtcDtcclxuICAgIHRoaXMud2Vla0RheUxhYmVscyA9IHRoaXMud2Vla0RheUxhYmVscyB8fCBnZXRMb2NhbGVEYXlOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLlN0YW5kYWxvbmUsIFRyYW5zbGF0aW9uV2lkdGguQWJicmV2aWF0ZWQpO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0RGF5KHRpbWVzdGFtcDogbnVtYmVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xyXG4gICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgIGNvbnN0IGRhdGUgPSAodHlwZW9mIHRpbWVzdGFtcCAhPT0gJ3VuZGVmaW5lZCcpID8gbmV3IERhdGUodGltZXN0YW1wKSA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XHJcbiAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaFZpZXcodGltZXN0YW1wOiBudW1iZXIsIHZpZXc6IFZpZXdNb2RlLCBkaXJlY3Rpb246IFpvb21EaXJlY3Rpb24pIHtcclxuICAgIHRoaXMuem9vbURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGltcGxlbWVudGF0aW9uXHJcblxyXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuZGF0ZSA9IG9iajtcclxuICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgfVxyXG5cclxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gIH1cclxuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUodGltaW5nOiBudW1iZXIgfCBzdHJpbmcgPSAxNTApOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEge1xyXG4gIHJldHVybiB0cmlnZ2VyKCdzbGlkZScsIFtcclxuICAgIHN0YXRlKCdwYW5uaW5nJywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKHt7eH19JSknLFxyXG4gICAgfSksIHtwYXJhbXM6IHt4OiAwfX0pLFxyXG4gICAgdHJhbnNpdGlvbignKiA9PiAxJywgYW5pbWF0ZSh0aW1pbmcsIHN0eWxlKHtcclxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLFxyXG4gICAgfSkpKSxcclxuICAgIHRyYW5zaXRpb24oJyogPT4gLTEnLCBhbmltYXRlKHRpbWluZywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyxcclxuICAgIH0pKSksXHJcbiAgICB0cmFuc2l0aW9uKCdwYW5uaW5nID0+IGlkbGUnLCBhbmltYXRlKHRpbWluZykpLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgTmdab25lLFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3V0cHV0LFxyXG4gIFNpbXBsZUNoYW5nZXMsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNyZWF0ZUVhc2VPdXQgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBzbGlkZSB9IGZyb20gJy4vc2xpZGUuYW5pbWF0aW9uJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmRlY2xhcmUgY2xhc3MgSGFtbWVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gIGNvbnN0cnVjdG9yKHRhcmdldDogRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblRyaWdnZXIge1xyXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgcGFyYW1zOiB7IFtwOiBzdHJpbmddOiBhbnkgfTtcclxufVxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tc2xpZGVyJyxcclxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1zbGlkZXJcIiBbQHNsaWRlXT1cInNsaWRlVHJpZ2dlclwiIChAc2xpZGUuZG9uZSk9XCJkb25lKCRldmVudClcIj5cclxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbjwvZGl2PlxyXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24gc2ttLXByZXZcIiAoY2xpY2spPVwic2xpZGUoLTEpXCIgW2Rpc2FibGVkXT1cInByZXZEaXNhYmxlZFwiPiZsc2FxdW87PC9idXR0b24+XHJcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2ttLWRhdGVwaWNrZXItcGFnaW5hdGlvbiBza20tbmV4dFwiIChjbGljayk9XCJzbGlkZSgxKVwiIFtkaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIj4mcnNhcXVvOzwvYnV0dG9uPlxyXG5gLFxyXG4gIHN0eWxlczogW2A6aG9zdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlfS5za20tZGF0ZXBpY2tlci1zbGlkZXJ7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTEwMCU7aGVpZ2h0OjEwMCV9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb257cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24uc2ttLXByZXZ7bGVmdDowfS5za20tZGF0ZXBpY2tlci1wYWdpbmF0aW9uLnNrbS1uZXh0e3JpZ2h0OjB9YCwgYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3NsaWRlKCldLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xyXG4gIEBJbnB1dCgpIHByZXZEaXNhYmxlZCA9IGZhbHNlO1xyXG4gIEBJbnB1dCgpIG5leHREaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICBAT3V0cHV0KCkgc2xpZGVEb25lID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XHJcbiAgbm90UGFubmluZyA9IHRydWU7XHJcblxyXG4gIHNsaWRlVHJpZ2dlcjogQW5pbWF0aW9uVHJpZ2dlcjtcclxuXHJcbiAgcHJpdmF0ZSB3cmFwcGVyV2lkdGggPSAxO1xyXG4gIHByaXZhdGUgcGFuT2Zmc2V0ID0gMDtcclxuICBwcml2YXRlIGxhc3REb25lRXZlbnRUb1N0YXRlOiBzdHJpbmcgfCBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbmdVbnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdCgpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZWFzZU91dCA9IGNyZWF0ZUVhc2VPdXQoMS4zKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHRoaXMuY2QuZGV0YWNoKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgY29uc3QgaG9zdCA9IHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50O1xyXG4gICAgICBmcm9tRXZlbnQoaG9zdCwgJ21vdXNlZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFByZXNzKCkpO1xyXG5cclxuICAgICAgaWYgKCdIYW1tZXInIGluIHdpbmRvdykge1xyXG4gICAgICAgIGNvbnN0IGhhbW1lciA9IG5ldyBIYW1tZXIoaG9zdCk7XHJcblxyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdwYW5zdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFBhbigpKTtcclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAncGFubW92ZScpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoZSA9PiB0aGlzLnBhbihlKSk7XHJcbiAgICAgICAgZnJvbUV2ZW50KGhhbW1lciwgJ3BhbmVuZCBwYW5jYW5jZWwnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZW5kUGFuKCkpO1xyXG5cclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAnc3dpcGVyaWdodCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zd2lwZSgtMSkpO1xyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdzd2lwZWxlZnQnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3dpcGUoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5uZXh0KCk7XHJcbiAgICB0aGlzLm5nVW5zdWJzY3JpYmUkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBkb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09IHRoaXMubGFzdERvbmVFdmVudFRvU3RhdGUpIHtcclxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjQwODRcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sYXN0RG9uZUV2ZW50VG9TdGF0ZSA9IGV2ZW50LnRvU3RhdGU7XHJcbiAgICBpZiAodHlwZW9mIGV2ZW50LnRvU3RhdGUgYXMgc3RyaW5nIHwgbnVtYmVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICB0aGlzLnNsaWRlRG9uZS5lbWl0KGV2ZW50LnRvU3RhdGUgYXMgYW55KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNsaWRlKGRpcmVjdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcihkaXJlY3Rpb24gYXMgLTEgfCAxKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0UHJlc3MoKTogdm9pZCB7XHJcbiAgICB0aGlzLm5vdFBhbm5pbmcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydFBhbigpOiB2b2lkIHtcclxuICAgIHRoaXMubm90UGFubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFuKGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZXZlbnQuZGVsdGFYID4gMCAmJiB0aGlzLnByZXZEaXNhYmxlZCB8fCBldmVudC5kZWx0YVggPCAwICYmIHRoaXMubmV4dERpc2FibGVkKSA/IDAuMSA6IDE7XHJcbiAgICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhldmVudC5kZWx0YVggLyB0aGlzLndyYXBwZXJXaWR0aCk7XHJcbiAgICB0aGlzLnBhbk9mZnNldCA9IE1hdGguc2lnbihldmVudC5kZWx0YVgpICogdGhpcy5lYXNlT3V0KGFic09mZnNldCk7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigncGFubmluZycsIHRoaXMucGFuT2Zmc2V0ICogbXVsdGlwbGllcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGVuZFBhbigpOiB2b2lkIHtcclxuICAgIGlmIChNYXRoLmFicyh0aGlzLnBhbk9mZnNldCkgPiAwLjUpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoLU1hdGguc2lnbih0aGlzLnBhbk9mZnNldCkgYXMgLTEgfCAxKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zbGlkZVRyaWdnZXIudmFsdWUgPT09ICdwYW5uaW5nJykge1xyXG4gICAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzd2lwZShkaXJlY3Rpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoZGlyZWN0aW9uIGFzIC0xIHwgMSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoYW5nZVNsaWRlVHJpZ2dlcih2YWx1ZTogJ3Bhbm5pbmcnIHwgJ2lkbGUnIHwgLTEgfCAxID0gJ2lkbGUnLCBvZmZzZXQgPSAwKTogdm9pZCB7XHJcbiAgICB0aGlzLnNsaWRlVHJpZ2dlciA9IHtcclxuICAgICAgdmFsdWU6ICh2YWx1ZSA9PT0gLTEgJiYgdGhpcy5wcmV2RGlzYWJsZWQgfHwgdmFsdWUgPT09IDEgJiYgdGhpcy5uZXh0RGlzYWJsZWQpID8gJ2lkbGUnIDogdmFsdWUsXHJcbiAgICAgIHBhcmFtczoge3g6IG9mZnNldCAqIDEwMH0sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgdHlwZSBab29tRGlyZWN0aW9uID0gJ2luJyB8ICdvdXQnO1xyXG5cclxuY29uc3QgYmlnZ2VyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5jb25zdCBzbWFsbGVyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMS4zKScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gem9vbSh0aW1pbmc6IG51bWJlciB8IHN0cmluZyA9IDE3NSk6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSB7XHJcbiAgcmV0dXJuIHRyaWdnZXIoJ3pvb20nLCBbXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IGluJywgW1xyXG4gICAgICBiaWdnZXJTdHlsZSxcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IG91dCcsIFtcclxuICAgICAgc21hbGxlclN0eWxlLFxyXG4gICAgICBhbmltYXRlKHRpbWluZyksXHJcbiAgICBdKSxcclxuICAgIHRyYW5zaXRpb24oJ2luID0+IHZvaWQnLCBbXHJcbiAgICAgIGFuaW1hdGUodGltaW5nLCBzbWFsbGVyU3R5bGUpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCdvdXQgPT4gdm9pZCcsIFtcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcsIGJpZ2dlclN0eWxlKSxcclxuICAgIF0pLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZpZXdTdHJhdGVneSB7XHJcbiAgYWJzdHJhY3QgcmVhZG9ubHkgdmlld01vZGU6IFZpZXdNb2RlO1xyXG4gIGFic3RyYWN0IHJlYWRvbmx5IGl0ZW1DbGFzczogc3RyaW5nO1xyXG5cclxuICBhYnN0cmFjdCBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gIGFic3RyYWN0IG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICBhYnN0cmFjdCBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lO1xyXG59XHJcbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyB6b29tLCBab29tRGlyZWN0aW9uIH0gZnJvbSAnLi4vdXRpbC96b29tLmFuaW1hdGlvbic7XHJcbmltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuLi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3NrbS12aWV3JyxcclxuICB0ZW1wbGF0ZTogYDxza20tc2xpZGVyIFtwcmV2RGlzYWJsZWRdPVwicHJldkRpc2FibGVkXCIgW25leHREaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIiAoc2xpZGVEb25lKT1cInN3aXRjaFBhbmVzKCRldmVudClcIiAjc2xpZGVyPlxyXG4gIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1wYW5lXCIgKm5nRm9yPVwibGV0IHBhbmUgb2YgcGFuZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXhcIiBbc3R5bGUub3JkZXJdPVwicGFuZS5vcmRlclwiPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1oZWFkZXJcIlxyXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xpY2tIZWFkZXIoc2xpZGVyLm5vdFBhbm5pbmcpXCIgW2Rpc2FibGVkXT1cInZpZXdTdHJhdGVneS52aWV3TW9kZSA9PT0gVmlld01vZGUuWWVhcnNcIj5cclxuICAgICAge3twYW5lLnZhbHVlc1swXSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ2aWV3U3RyYXRlZ3kudmlld01vZGUgPT09IFZpZXdNb2RlLlllYXJzXCI+XHJcbiAgICAgICAgJm5kYXNoOyB7e3BhbmUudmFsdWVzWzE5XSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla1wiICpuZ0lmPVwidmlld1N0cmF0ZWd5LnZpZXdNb2RlID09PSBWaWV3TW9kZS5EYXlzXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci13ZWVrZGF5XCIgKm5nRm9yPVwibGV0IGxhYmVsIG9mIHdlZWtEYXlMYWJlbHMgfCBzbGljZTp3ZWVrU3RhcnQ6N1wiPnt7bGFiZWx9fTwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla2RheVwiICpuZ0Zvcj1cImxldCBsYWJlbCBvZiB3ZWVrRGF5TGFiZWxzIHwgc2xpY2U6MDp3ZWVrU3RhcnRcIj57e2xhYmVsfX08L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPHNrbS1ncmlkXHJcbiAgICAgIFtwYW5lXT1cInBhbmVcIlxyXG4gICAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgICAgW3NlbGVjdGVkVGltZXN0YW1wXT1cInNlbGVjdGVkVGltZXN0YW1wXCJcclxuICAgICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcbiAgICAgIFtpdGVtRm9ybWF0XT1cIml0ZW1Gb3JtYXRcIlxyXG4gICAgICBbaXRlbUxhYmVsc109XCJpdGVtTGFiZWxzXCJcclxuICAgID48L3NrbS1ncmlkPlxyXG4gIDwvZGl2PlxyXG48L3NrbS1zbGlkZXI+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3pvb20oKV0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ0B6b29tJykgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICBASW5wdXQoKSBpbml0aWFsVGltZXN0YW1wOiBudW1iZXI7XHJcblxyXG4gIEBJbnB1dCgpIGN1cnJlbnRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBzZWxlY3RlZFRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1pblRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1heFRpbWVzdGFtcDogbnVtYmVyO1xyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGhlYWRpbmdGb3JtYXQ6IHN0cmluZztcclxuICBASW5wdXQoKSB3ZWVrU3RhcnQ6IFdlZWtEYXk7XHJcbiAgQElucHV0KCkgd2Vla0RheUxhYmVsczogc3RyaW5nW107XHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdO1xyXG5cclxuICBAT3V0cHV0KCkgcmVhZG9ubHkgaXRlbUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG4gIEBPdXRwdXQoKSByZWFkb25seSBoZWFkZXJDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwYW5lczogQXJyYXk8UGFuZT47XHJcbiAgcHJldkRpc2FibGVkID0gZmFsc2U7XHJcbiAgbmV4dERpc2FibGVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSB2aXNpYmxlUGFuZUluZGV4OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSByZWd1bGFyVGltZXN0YW1wRmllbGRzID0gWydjdXJyZW50VGltZXN0YW1wJywgJ3NlbGVjdGVkVGltZXN0YW1wJywgJ21pblRpbWVzdGFtcCcsICdtYXhUaW1lc3RhbXAnXTtcclxuXHJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnZpZXdTdHJhdGVneS52aWV3TW9kZSAhPT0gVmlld01vZGUuRGF5cykge1xyXG4gICAgICB0aGlzLnJlZ3VsYXJUaW1lc3RhbXBGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgaWYgKGZpZWxkIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXNbZmllbGRdID0gdGhpc1tmaWVsZF0gPyB0aGlzLnZpZXdTdHJhdGVneS5ub3JtYWxpemVUaW1lc3RhbXAodGhpc1tmaWVsZF0pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ2luaXRpYWxUaW1lc3RhbXAnIGluIGNoYW5nZXMpIHtcclxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgbm9ybWFsaXphdGlvbiBvZiBvdGhlciB0aW1lc3RhbXBzIGZvciBwcm9wZXIgYmVoYXZpb3Igb2YgbWluLW1heCByYW5nZVxyXG4gICAgICB0aGlzLmluaXRQYW5lcyh0aGlzLmluaXRpYWxUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIGNsaWNrSGVhZGVyKG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIHRoaXMuaGVhZGVyQ2xpY2suZW1pdCh0aGlzLnBhbmVzW3RoaXMudmlzaWJsZVBhbmVJbmRleF0udmFsdWVzWzBdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlbGVjdEl0ZW0oZXZlbnQ6IE1vdXNlRXZlbnQsIHBhbmU6IFBhbmUsIG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgICAgY29uc3QgaW5kZXggPSBidXR0b24uZGF0YXNldC5pbmRleDtcclxuICAgICAgaWYgKHRoaXMuZGVzZWxlY3RFbmFibGVkICYmIHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICAgIHRoaXMuaXRlbUNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pdGVtQ2hhbmdlLmVtaXQocGFuZS52YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3dpdGNoUGFuZXMoZGlyZWN0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudmlzaWJsZVBhbmVJbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBpbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBwYW5lID0gdGhpcy5wYW5lc1tpbmRleF07XHJcbiAgICB0aGlzLnBhbmVzW2luZGV4XSA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VQYW5lKHBhbmUudmFsdWVzWzBdLCAzICogZGlyZWN0aW9uLCBwYW5lLm9yZGVyLCB0aGlzLndlZWtTdGFydCk7XHJcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkU3RhdHVzKCgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4IC0gMSkgJSAzLCAoMyArIHRoaXMudmlzaWJsZVBhbmVJbmRleCArIDEpICUgMyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRQYW5lcyh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc2VlZCA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcCk7XHJcbiAgICB0aGlzLnBhbmVzID0gWy0xLCAwLCAxXS5tYXAoaSA9PiB0aGlzLnZpZXdTdHJhdGVneS5tYWtlUGFuZShzZWVkLCBpLCAwLCB0aGlzLndlZWtTdGFydCkpO1xyXG4gICAgdGhpcy52aXNpYmxlUGFuZUluZGV4ID0gMTtcclxuICAgIHRoaXMudXBkYXRlRGlzYWJsZWRTdGF0dXMoMCwgMik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZURpc2FibGVkU3RhdHVzKHByZXZJbmRleDogbnVtYmVyLCBuZXh0SW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5wcmV2RGlzYWJsZWQgPSB0aGlzLnBhbmVzW3ByZXZJbmRleF0udmFsdWVzW3RoaXMucGFuZXNbcHJldkluZGV4XS52YWx1ZXMubGVuZ3RoIC0gMV0gPCB0aGlzLm1pblRpbWVzdGFtcDtcclxuICAgIHRoaXMubmV4dERpc2FibGVkID0gdGhpcy5wYW5lc1tuZXh0SW5kZXhdLnZhbHVlc1swXSA+IHRoaXMubWF4VGltZXN0YW1wO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuLi9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFZpZXdTdHJhdGVneSB9IGZyb20gJy4uL3ZpZXctc3RyYXRlZ2llcy92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld0NvbXBvbmVudCB9IGZyb20gJy4uL3ZpZXcvdmlldy5jb21wb25lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZ3JpZCcsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItZ3JpZFwiIChjbGljayk9XCJwYXJlbnRWaWV3LnNlbGVjdEl0ZW0oJGV2ZW50LCBwYW5lLCBzbGlkZXIubm90UGFubmluZylcIj5cclxuICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItaW5kZW50XCIgW3N0eWxlLndpZHRoLiVdPVwiMTAwIC8gNyAqIHBhbmUuaW5kZW50XCI+PC9kaXY+XHJcbiAgPGRpdiAqbmdGb3I9XCJsZXQgdmFsdWUgb2YgcGFuZS52YWx1ZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXg7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLWNlbGxcIj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIFthdHRyLmRhdGEtaW5kZXhdPVwiaVwiIFtjbGFzc109XCJtYWtlSXRlbUNsYXNzZXMoaSwgcGFuZSlcIiBbZGlzYWJsZWRdPVwiaXNEaXNhYmxlZChpLCBwYW5lKVwiPlxyXG4gICAgICB7e2l0ZW1MYWJlbHNbaV0gfHwgKHZhbHVlIHwgZGF0ZTppdGVtRm9ybWF0KX19XHJcbiAgICA8L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBHcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBwYW5lOiBQYW5lO1xyXG5cclxuICBASW5wdXQoKSBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgQElucHV0KCkgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKSByZWFkb25seSBfaG9zdENsYXNzID0gJ3NrbS1kYXRlcGlja2VyLWNvbnRlbnQnO1xyXG5cclxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBzbGlkZXI6IFNsaWRlckNvbXBvbmVudCxcclxuICAgICAgICAgICAgICByZWFkb25seSBwYXJlbnRWaWV3OiBWaWV3Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnaXRlbUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLml0ZW1MYWJlbHMgPSB0aGlzLml0ZW1MYWJlbHMgfHwgW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtYWtlSXRlbUNsYXNzZXMoaW5kZXg6IG51bWJlciwgcGFuZTogUGFuZSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLnZpZXdTdHJhdGVneS5pdGVtQ2xhc3MsXHJcbiAgICAgICdza20tZGF0ZXBpY2tlci1pdGVtJyxcclxuICAgICAgKHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5jdXJyZW50VGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1jdXJyZW50JyA6ICcnLFxyXG4gICAgICAocGFuZS52YWx1ZXNbaW5kZXhdID09PSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1zZWxlY3RlZCcgOiAnJyxcclxuICAgIF0uam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgaXNEaXNhYmxlZChpbmRleDogbnVtYmVyLCBwYW5lOiBQYW5lKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKHBhbmUudmFsdWVzW2luZGV4XSA8IHRoaXMubWluVGltZXN0YW1wKSB8fCAocGFuZS52YWx1ZXNbaW5kZXhdID4gdGhpcy5tYXhUaW1lc3RhbXApO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4uL2RhdGVwaWNrZXIvdmlldy1tb2RlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgc3RhcnRPZk1vbnRoIH0gZnJvbSAnLi4vdXRpbC9oZWxwZXJzJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3NrbURheXNTdHJhdGVneV0nLFxyXG4gIHByb3ZpZGVyczogW1xyXG4gICAge3Byb3ZpZGU6IFZpZXdTdHJhdGVneSwgdXNlRXhpc3Rpbmc6IERheXNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIERheXNTdHJhdGVneURpcmVjdGl2ZSBleHRlbmRzIFZpZXdTdHJhdGVneSB7XHJcbiAgcmVhZG9ubHkgdmlld01vZGUgPSBWaWV3TW9kZS5EYXlzO1xyXG4gIHJlYWRvbmx5IGl0ZW1DbGFzcyA9ICdza20tZGF0ZXBpY2tlci1kYXknO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcclxuICB9XHJcblxyXG4gIG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzdGFydE9mTW9udGgodGltZXN0YW1wKS52YWx1ZU9mKCk7XHJcbiAgfVxyXG5cclxuICBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgZGF0ZS5zZXRNb250aChhZGQgKyBkYXRlLmdldE1vbnRoKCkpO1xyXG4gICAgY29uc3QgZmlyc3REYXkgPSBkYXRlLmdldERheSgpO1xyXG5cclxuICAgIGRhdGUuc2V0TW9udGgoMSArIGRhdGUuZ2V0TW9udGgoKSk7XHJcbiAgICBkYXRlLnNldERhdGUoMCk7XHJcbiAgICBjb25zdCBtb250aExlbmd0aCA9IGRhdGUuZ2V0RGF0ZSgpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbW9udGhMZW5ndGg7IGkrKykge1xyXG4gICAgICB2YWx1ZXMucHVzaChkYXRlLnNldERhdGUoaSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9yZGVyOiBiYXNlT3JkZXIgKyBhZGQsXHJcbiAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICBpbmRlbnQ6IChmaXJzdERheSAtIHdlZWtTdGFydCArIDcpICUgNyB8fCA3LCAvLyBEZWZhdWx0aW5nIHRvIGZ1bGwgd2VlayBtYWtlcyBmb3IgbW9yZSBhIGJhbGFuY2VkIGNlbGxzIGxheW91dFxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IHN0YXJ0T2ZZZWFyIH0gZnJvbSAnLi4vdXRpbC9oZWxwZXJzJztcclxuaW1wb3J0IHsgVmlld1N0cmF0ZWd5IH0gZnJvbSAnLi92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld01vZGUgfSBmcm9tICcuLi9kYXRlcGlja2VyL3ZpZXctbW9kZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbc2ttTW9udGhzU3RyYXRlZ3ldJyxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBWaWV3U3RyYXRlZ3ksIHVzZUV4aXN0aW5nOiBNb250aHNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIE1vbnRoc1N0cmF0ZWd5RGlyZWN0aXZlIGV4dGVuZHMgVmlld1N0cmF0ZWd5IHtcclxuICByZWFkb25seSB2aWV3TW9kZSA9IFZpZXdNb2RlLk1vbnRocztcclxuICByZWFkb25seSBpdGVtQ2xhc3MgPSAnc2ttLWRhdGVwaWNrZXItbW9udGgnO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkuc2V0RGF0ZSgxKTtcclxuICB9XHJcblxyXG4gIG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzdGFydE9mWWVhcih0aW1lc3RhbXApLnZhbHVlT2YoKTtcclxuICB9XHJcblxyXG4gIG1ha2VQYW5lKHRpbWVzdGFtcDogbnVtYmVyLCBhZGQ6IG51bWJlciwgYmFzZU9yZGVyOiBudW1iZXIsIHdlZWtTdGFydDogV2Vla0RheSk6IFBhbmUge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGFkZCArIGRhdGUuZ2V0RnVsbFllYXIoKSk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgdmFsdWVzLnB1c2goZGF0ZS5zZXRNb250aChpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JkZXI6IGJhc2VPcmRlciArIGFkZCxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi9wYW5lJztcclxuaW1wb3J0IHsgc3RhcnRPZlllYXIgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4uL2RhdGVwaWNrZXIvdmlldy1tb2RlJztcclxuaW1wb3J0IHsgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tza21ZZWFyc1N0cmF0ZWd5XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogVmlld1N0cmF0ZWd5LCB1c2VFeGlzdGluZzogWWVhcnNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIFllYXJzU3RyYXRlZ3lEaXJlY3RpdmUgZXh0ZW5kcyBWaWV3U3RyYXRlZ3kge1xyXG4gIHJlYWRvbmx5IHZpZXdNb2RlID0gVmlld01vZGUuWWVhcnM7XHJcbiAgcmVhZG9ubHkgaXRlbUNsYXNzID0gJ3NrbS1kYXRlcGlja2VyLXllYXInO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkuc2V0TW9udGgoMCwgMSk7XHJcbiAgfVxyXG5cclxuICBtYWtlSW5pdFBhbmVzU2VlZCh0aW1lc3RhbXA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKTtcclxuICAgIGNvbnN0IG9yaWdpbiA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIGNvbnN0IGFkanVzdGVkID0gb3JpZ2luIC0gKG9yaWdpbiAlIDIwKTtcclxuICAgIHJldHVybiBzdGFydE9mWWVhcihkYXRlKS5zZXRGdWxsWWVhcihhZGp1c3RlZCk7XHJcbiAgfVxyXG5cclxuICBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgY29uc3Qgb3JpZ2luID0gYWRkICogMjAgKyBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICAgICAgdmFsdWVzLnB1c2goZGF0ZS5zZXRGdWxsWWVhcihvcmlnaW4gKyBpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JkZXI6IGJhc2VPcmRlciArIGFkZCxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgRGF0ZXBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFNsaWRlckNvbXBvbmVudCB9IGZyb20gJy4vc2xpZGVyL3NsaWRlci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi92aWV3L3ZpZXcuY29tcG9uZW50JztcclxuaW1wb3J0IHsgR3JpZENvbXBvbmVudCB9IGZyb20gJy4vZ3JpZC9ncmlkLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IERheXNTdHJhdGVneURpcmVjdGl2ZSB9IGZyb20gJy4vdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgTW9udGhzU3RyYXRlZ3lEaXJlY3RpdmUgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ2llcy9tb250aHMtc3RyYXRlZ3kuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgWWVhcnNTdHJhdGVneURpcmVjdGl2ZSB9IGZyb20gJy4vdmlldy1zdHJhdGVnaWVzL3llYXJzLXN0cmF0ZWd5LmRpcmVjdGl2ZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZSxcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW1xyXG4gICAgRGF0ZXBpY2tlckNvbXBvbmVudCxcclxuICAgIFZpZXdDb21wb25lbnQsXHJcbiAgICBTbGlkZXJDb21wb25lbnQsXHJcbiAgICBHcmlkQ29tcG9uZW50LFxyXG4gICAgRGF5c1N0cmF0ZWd5RGlyZWN0aXZlLFxyXG4gICAgTW9udGhzU3RyYXRlZ3lEaXJlY3RpdmUsXHJcbiAgICBZZWFyc1N0cmF0ZWd5RGlyZWN0aXZlLFxyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgRGF0ZXBpY2tlckNvbXBvbmVudCxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlck1vZHVsZSB7XHJcbn1cclxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUJBQTRCLElBQVU7SUFDcEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUMvQjs7Ozs7QUFFRCxvQkFBMkIsSUFBbUI7SUFDNUMscUJBQU0sQ0FBQyxHQUFHLElBQUksSUFBSSxtQkFBQyxJQUFjLEVBQUMsQ0FBQztJQUNuQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLE9BQU8sQ0FBQyxDQUFDO0NBQ1Y7Ozs7O0FBRUQsc0JBQTZCLElBQW1CO0lBQzlDLHFCQUFNLENBQUMsR0FBRyxJQUFJLElBQUksbUJBQUMsSUFBYyxFQUFDLENBQUM7SUFDbkMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2IsT0FBTyxDQUFDLENBQUM7Q0FDVjs7Ozs7QUFFRCxxQkFBNEIsSUFBbUI7SUFDN0MscUJBQU0sQ0FBQyxHQUFHLElBQUksSUFBSSxtQkFBQyxJQUFjLEVBQUMsQ0FBQztJQUNuQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxDQUFDO0NBQ1Y7Ozs7O0FBR0QsdUJBQThCLFFBQWdCO0lBQzVDLHFCQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FB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