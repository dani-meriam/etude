import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Input, LOCALE_ID, Output, ElementRef, NgZone, HostBinding, Directive, NgModule } from '@angular/core';
import { FormStyle, getLocaleDayNames, TranslationWidth, WeekDay, CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { fromEvent, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} date
 * @return {?}
 */
function isValidDate(date) {
    return !isNaN(date.getTime());
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfDay(date) {
    const /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    return d;
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfMonth(date) {
    const /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    d.setDate(1);
    return d;
}
/**
 * @param {?} date
 * @return {?}
 */
function startOfYear(date) {
    const /** @type {?} */ d = new Date(/** @type {?} */ (date));
    d.setHours(0, 0, 0, 0);
    d.setMonth(0, 1);
    return d;
}
/**
 * @param {?} panRatio
 * @return {?}
 */
function createEaseOut(panRatio) {
    const /** @type {?} */ a = (panRatio - 2) / Math.pow(panRatio, 3);
    const /** @type {?} */ b = (3 - 2 * panRatio) / Math.pow(panRatio, 2);
    return function easeOut(x) {
        return (x >= panRatio) ? 1 : ((a * x + b) * x + 1) * x;
    };
}
/**
 * @return {?}
 */
function noop() {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const ViewMode = {
    Days: 'days',
    Months: 'months',
    Years: 'years',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DatepickerComponent {
    /**
     * @param {?} cd
     * @param {?} locale
     */
    constructor(cd, locale) {
        this.cd = cd;
        this.locale = locale;
        this.dateChange = new EventEmitter();
        this.dayFormat = 'd';
        this.monthFormat = 'MMM';
        this.yearFormat = 'y';
        this.headingFormat = 'MMMM y';
        this.weekStart = WeekDay.Monday;
        this.view = ViewMode.Days;
        this.ViewMode = ViewMode;
        this.onChange = noop;
        this.onTouched = noop;
    }
    /**
     * @param {?} dirtyDate
     * @return {?}
     */
    set date(dirtyDate) {
        if (dirtyDate == null) {
            this.selectedTimestamp = undefined;
            return;
        }
        const /** @type {?} */ date = startOfDay(dirtyDate);
        if (date.getTime() !== this.selectedTimestamp) {
            this.selectedTimestamp = isValidDate(date) ? date.getTime() : undefined;
            if (typeof this.selectedTimestamp !== 'undefined') {
                this.initialTimestamp = this.selectedTimestamp;
                this.view = ViewMode.Days;
            }
        }
    }
    /**
     * @param {?} dirtyDate
     * @return {?}
     */
    set min(dirtyDate) {
        const /** @type {?} */ date = startOfDay(dirtyDate);
        this.minTimestamp = isValidDate(date) ? date.valueOf() : undefined;
    }
    /**
     * @param {?} dirtyDate
     * @return {?}
     */
    set max(dirtyDate) {
        const /** @type {?} */ date = startOfDay(dirtyDate);
        this.maxTimestamp = isValidDate(date) ? date.valueOf() : undefined;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('weekDayLabels' in changes) {
            this.weekDayLabels = this.weekDayLabels || getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.currentTimestamp = startOfDay(new Date()).getTime();
        this.initialTimestamp = this.selectedTimestamp || this.currentTimestamp;
        this.weekDayLabels = this.weekDayLabels || getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    selectDay(timestamp) {
        console.log(timestamp);
        this.selectedTimestamp = timestamp;
        const /** @type {?} */ date = (typeof timestamp !== 'undefined') ? new Date(timestamp) : undefined;
        this.onChange(date);
        this.dateChange.emit(date);
    }
    /**
     * @param {?} timestamp
     * @param {?} view
     * @param {?} direction
     * @return {?}
     */
    switchView(timestamp, view, direction) {
        this.zoomDirection = direction;
        setTimeout(() => {
            this.initialTimestamp = timestamp;
            this.view = view;
            this.cd.markForCheck();
        });
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        this.date = obj;
        this.cd.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
        // TODO implement
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        // TODO implement
        this.cd.markForCheck();
    }
}
DatepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'skm-datepicker',
                template: `<div class="skm-datepicker" [ngSwitch]="view">
  <skm-view
    *ngSwitchCase="ViewMode.Days"
    skmDaysStrategy
    class="skm-datepicker-view skm-datepicker-days-view"
    [zoomDirection]="zoomDirection"
    [initialTimestamp]="initialTimestamp"

    [currentTimestamp]="currentTimestamp"
    [selectedTimestamp]="selectedTimestamp"
    [minTimestamp]="minTimestamp"
    [maxTimestamp]="maxTimestamp"

    [deselectEnabled]="deselectEnabled"

    [headingFormat]="headingFormat"
    [weekStart]="weekStart"
    [weekDayLabels]="weekDayLabels"
    [itemFormat]="dayFormat"
    [itemLabels]="dayLabels"

    (headerClick)="switchView($event, ViewMode.Months, 'out')"
    (itemChange)="selectDay($event)"
  ></skm-view>
  <skm-view
    *ngSwitchCase="ViewMode.Months"
    skmMonthsStrategy
    class="skm-datepicker-view skm-datepicker-months-view"
    [zoomDirection]="zoomDirection"
    [initialTimestamp]="initialTimestamp"

    [currentTimestamp]="currentTimestamp"
    [selectedTimestamp]="selectedTimestamp"
    [minTimestamp]="minTimestamp"
    [maxTimestamp]="maxTimestamp"

    [headingFormat]="yearFormat"
    [itemFormat]="monthFormat"
    [itemLabels]="monthLabels"

    (headerClick)="switchView($event, ViewMode.Years, 'out')"
    (itemChange)="switchView($event, ViewMode.Days, 'in')"
  ></skm-view>
  <skm-view
    *ngSwitchCase="ViewMode.Years"
    skmYearsStrategy
    class="skm-datepicker-view skm-datepicker-years-view"
    [zoomDirection]="zoomDirection"
    [initialTimestamp]="initialTimestamp"

    [currentTimestamp]="currentTimestamp"
    [selectedTimestamp]="selectedTimestamp"
    [minTimestamp]="minTimestamp"
    [maxTimestamp]="maxTimestamp"

    [headingFormat]="yearFormat"
    [itemFormat]="yearFormat"

    (itemChange)="switchView($event, ViewMode.Months, 'in')"
  ></skm-view>
</div>
`,
                styles: [`.skm-datepicker{position:relative;overflow:hidden}.skm-datepicker-view{display:block;position:absolute;height:100%;width:100%}`, `button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: DatepickerComponent, multi: true },
                ],
            },] },
];
/** @nocollapse */
DatepickerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] },] },
];
DatepickerComponent.propDecorators = {
    "date": [{ type: Input },],
    "dateChange": [{ type: Output },],
    "min": [{ type: Input },],
    "max": [{ type: Input },],
    "deselectEnabled": [{ type: Input },],
    "dayFormat": [{ type: Input },],
    "monthFormat": [{ type: Input },],
    "yearFormat": [{ type: Input },],
    "headingFormat": [{ type: Input },],
    "weekStart": [{ type: Input },],
    "dayLabels": [{ type: Input },],
    "weekDayLabels": [{ type: Input },],
    "monthLabels": [{ type: Input },],
    "view": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?=} timing
 * @return {?}
 */
function slide(timing = 150) {
    return trigger('slide', [
        state('panning', style({
            transform: 'translateX({{x}}%)',
        }), { params: { x: 0 } }),
        transition('* => 1', animate(timing, style({
            transform: 'translateX(-100%)',
        }))),
        transition('* => -1', animate(timing, style({
            transform: 'translateX(100%)',
        }))),
        transition('panning => idle', animate(timing)),
    ]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SliderComponent {
    /**
     * @param {?} hostRef
     * @param {?} cd
     * @param {?} zone
     */
    constructor(hostRef, cd, zone) {
        this.hostRef = hostRef;
        this.cd = cd;
        this.zone = zone;
        this.prevDisabled = false;
        this.nextDisabled = false;
        this.slideDone = new EventEmitter();
        this.notPanning = true;
        this.wrapperWidth = 1;
        this.panOffset = 0;
        this.ngUnsubscribe$ = new Subject();
        this.easeOut = createEaseOut(1.3);
        this.cd.detach();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.changeSlideTrigger();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.zone.runOutsideAngular(() => {
            const /** @type {?} */ host = this.hostRef.nativeElement;
            fromEvent(host, 'mousedown').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => this.startPress());
            if ('Hammer' in window) {
                const /** @type {?} */ hammer = new Hammer(host);
                fromEvent(hammer, 'panstart').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => this.startPan());
                fromEvent(hammer, 'panmove').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(e => this.pan(e));
                fromEvent(hammer, 'panend pancancel').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => this.endPan());
                fromEvent(hammer, 'swiperight').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => this.swipe(-1));
                fromEvent(hammer, 'swipeleft').pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => this.swipe(1));
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    done(event) {
        if (event.toState === this.lastDoneEventToState) {
            // workaround for https://github.com/angular/angular/issues/24084
            return;
        }
        this.lastDoneEventToState = event.toState;
        if (/** @type {?} */ (typeof event.toState) === 'number') {
            this.slideDone.emit(/** @type {?} */ (event.toState));
        }
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    slide(direction) {
        this.changeSlideTrigger();
        setTimeout(() => this.changeSlideTrigger(/** @type {?} */ (direction)));
    }
    /**
     * @return {?}
     */
    startPress() {
        this.notPanning = true;
    }
    /**
     * @return {?}
     */
    startPan() {
        this.notPanning = false;
        this.wrapperWidth = this.hostRef.nativeElement.offsetWidth;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    pan(event) {
        const /** @type {?} */ multiplier = (event.deltaX > 0 && this.prevDisabled || event.deltaX < 0 && this.nextDisabled) ? 0.1 : 1;
        const /** @type {?} */ absOffset = Math.abs(event.deltaX / this.wrapperWidth);
        this.panOffset = Math.sign(event.deltaX) * this.easeOut(absOffset);
        this.changeSlideTrigger('panning', this.panOffset * multiplier);
    }
    /**
     * @return {?}
     */
    endPan() {
        if (Math.abs(this.panOffset) > 0.5) {
            this.changeSlideTrigger(/** @type {?} */ (-Math.sign(this.panOffset)));
        }
        else if (this.slideTrigger.value === 'panning') {
            this.changeSlideTrigger();
        }
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    swipe(direction) {
        this.changeSlideTrigger(/** @type {?} */ (direction));
    }
    /**
     * @param {?=} value
     * @param {?=} offset
     * @return {?}
     */
    changeSlideTrigger(value = 'idle', offset = 0) {
        this.slideTrigger = {
            value: (value === -1 && this.prevDisabled || value === 1 && this.nextDisabled) ? 'idle' : value,
            params: { x: offset * 100 },
        };
        this.cd.detectChanges();
    }
}
SliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'skm-slider',
                template: `<div class="skm-datepicker-slider" [@slide]="slideTrigger" (@slide.done)="done($event)">
  <ng-content></ng-content>
</div>
<button type="button" class="skm-datepicker-pagination skm-prev" (click)="slide(-1)" [disabled]="prevDisabled">&lsaquo;</button>
<button type="button" class="skm-datepicker-pagination skm-next" (click)="slide(1)" [disabled]="nextDisabled">&rsaquo;</button>
`,
                styles: [`:host{display:block;position:relative;height:100%}.skm-datepicker-slider{display:flex;position:relative;left:-100%;height:100%}.skm-datepicker-pagination{position:absolute;top:0}.skm-datepicker-pagination.skm-prev{left:0}.skm-datepicker-pagination.skm-next{right:0}`, `button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}`],
                animations: [slide()],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
SliderComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
SliderComponent.propDecorators = {
    "prevDisabled": [{ type: Input },],
    "nextDisabled": [{ type: Input },],
    "slideDone": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ biggerStyle = style({
    transform: 'scale(0.8)',
    opacity: 0,
});
const /** @type {?} */ smallerStyle = style({
    transform: 'scale(1.3)',
    opacity: 0,
});
/**
 * @param {?=} timing
 * @return {?}
 */
function zoom(timing = 175) {
    return trigger('zoom', [
        transition('void => in', [
            biggerStyle,
            animate(timing),
        ]),
        transition('void => out', [
            smallerStyle,
            animate(timing),
        ]),
        transition('in => void', [
            animate(timing, smallerStyle),
        ]),
        transition('out => void', [
            animate(timing, biggerStyle),
        ]),
    ]);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
class ViewStrategy {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ViewComponent {
    /**
     * @param {?} viewStrategy
     */
    constructor(viewStrategy) {
        this.viewStrategy = viewStrategy;
        this.itemChange = new EventEmitter();
        this.headerClick = new EventEmitter();
        this.ViewMode = ViewMode;
        this.prevDisabled = false;
        this.nextDisabled = false;
        this.regularTimestampFields = ['currentTimestamp', 'selectedTimestamp', 'minTimestamp', 'maxTimestamp'];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.viewStrategy.viewMode !== ViewMode.Days) {
            this.regularTimestampFields.forEach(field => {
                if (field in changes) {
                    this[field] = this[field] ? this.viewStrategy.normalizeTimestamp(this[field]) : undefined;
                }
            });
        }
        if ('initialTimestamp' in changes) {
            // Must be called after normalization of other timestamps for proper behavior of min-max range
            this.initPanes(this.initialTimestamp);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    trackIndex(index) {
        return index;
    }
    /**
     * @param {?} notPanning
     * @return {?}
     */
    clickHeader(notPanning) {
        if (notPanning) {
            this.headerClick.emit(this.panes[this.visiblePaneIndex].values[0]);
        }
    }
    /**
     * @param {?} event
     * @param {?} pane
     * @param {?} notPanning
     * @return {?}
     */
    selectItem(event, pane, notPanning) {
        if (notPanning) {
            const /** @type {?} */ button = /** @type {?} */ (event.target);
            const /** @type {?} */ index = button.dataset["index"];
            if (this.deselectEnabled && pane.values[index] === this.selectedTimestamp) {
                this.itemChange.emit(undefined);
            }
            else {
                this.itemChange.emit(pane.values[index]);
            }
        }
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    switchPanes(direction) {
        this.visiblePaneIndex = (3 + this.visiblePaneIndex + direction) % 3;
        const /** @type {?} */ index = (3 + this.visiblePaneIndex + direction) % 3;
        const /** @type {?} */ pane = this.panes[index];
        this.panes[index] = this.viewStrategy.makePane(pane.values[0], 3 * direction, pane.order, this.weekStart);
        this.updateDisabledStatus((3 + this.visiblePaneIndex - 1) % 3, (3 + this.visiblePaneIndex + 1) % 3);
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    initPanes(timestamp) {
        const /** @type {?} */ seed = this.viewStrategy.makeInitPanesSeed(timestamp);
        this.panes = [-1, 0, 1].map(i => this.viewStrategy.makePane(seed, i, 0, this.weekStart));
        this.visiblePaneIndex = 1;
        this.updateDisabledStatus(0, 2);
    }
    /**
     * @param {?} prevIndex
     * @param {?} nextIndex
     * @return {?}
     */
    updateDisabledStatus(prevIndex, nextIndex) {
        this.prevDisabled = this.panes[prevIndex].values[this.panes[prevIndex].values.length - 1] < this.minTimestamp;
        this.nextDisabled = this.panes[nextIndex].values[0] > this.maxTimestamp;
    }
}
ViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'skm-view',
                template: `<skm-slider [prevDisabled]="prevDisabled" [nextDisabled]="nextDisabled" (slideDone)="switchPanes($event)" #slider>
  <div class="skm-datepicker-pane" *ngFor="let pane of panes; trackBy: trackIndex" [style.order]="pane.order">
    <button type="button" class="skm-datepicker-header"
            (click)="clickHeader(slider.notPanning)" [disabled]="viewStrategy.viewMode === ViewMode.Years">
      {{pane.values[0] | date:headingFormat}}
      <ng-container *ngIf="viewStrategy.viewMode === ViewMode.Years">
        &ndash; {{pane.values[19] | date:headingFormat}}
      </ng-container>
    </button>
    <div class="skm-datepicker-week" *ngIf="viewStrategy.viewMode === ViewMode.Days">
      <div class="skm-datepicker-weekday" *ngFor="let label of weekDayLabels | slice:weekStart:7">{{label}}</div>
      <div class="skm-datepicker-weekday" *ngFor="let label of weekDayLabels | slice:0:weekStart">{{label}}</div>
    </div>
    <skm-grid
      [pane]="pane"
      [currentTimestamp]="currentTimestamp"
      [selectedTimestamp]="selectedTimestamp"
      [minTimestamp]="minTimestamp"
      [maxTimestamp]="maxTimestamp"
      [itemFormat]="itemFormat"
      [itemLabels]="itemLabels"
    ></skm-grid>
  </div>
</skm-slider>
`,
                styles: [`button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}`],
                animations: [zoom()],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
ViewComponent.ctorParameters = () => [
    { type: ViewStrategy, },
];
ViewComponent.propDecorators = {
    "zoomDirection": [{ type: Input }, { type: HostBinding, args: ['@zoom',] },],
    "initialTimestamp": [{ type: Input },],
    "currentTimestamp": [{ type: Input },],
    "selectedTimestamp": [{ type: Input },],
    "minTimestamp": [{ type: Input },],
    "maxTimestamp": [{ type: Input },],
    "deselectEnabled": [{ type: Input },],
    "headingFormat": [{ type: Input },],
    "weekStart": [{ type: Input },],
    "weekDayLabels": [{ type: Input },],
    "itemFormat": [{ type: Input },],
    "itemLabels": [{ type: Input },],
    "itemChange": [{ type: Output },],
    "headerClick": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GridComponent {
    /**
     * @param {?} slider
     * @param {?} parentView
     * @param {?} viewStrategy
     */
    constructor(slider, parentView, viewStrategy) {
        this.slider = slider;
        this.parentView = parentView;
        this.viewStrategy = viewStrategy;
        this.itemLabels = [];
        this._hostClass = 'skm-datepicker-content';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('itemLabels' in changes) {
            this.itemLabels = this.itemLabels || [];
        }
    }
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    makeItemClasses(index, pane) {
        return [
            this.viewStrategy.itemClass,
            'skm-datepicker-item',
            (pane.values[index] === this.currentTimestamp) ? 'skm-datepicker-current' : '',
            (pane.values[index] === this.selectedTimestamp) ? 'skm-datepicker-selected' : '',
        ].join(' ');
    }
    /**
     * @param {?} index
     * @param {?} pane
     * @return {?}
     */
    isDisabled(index, pane) {
        return (pane.values[index] < this.minTimestamp) || (pane.values[index] > this.maxTimestamp);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    trackIndex(index) {
        return index;
    }
}
GridComponent.decorators = [
    { type: Component, args: [{
                selector: 'skm-grid',
                template: `<div class="skm-datepicker-grid" (click)="parentView.selectItem($event, pane, slider.notPanning)">
  <div class="skm-datepicker-indent" [style.width.%]="100 / 7 * pane.indent"></div>
  <div *ngFor="let value of pane.values; trackBy: trackIndex; let i = index" class="skm-datepicker-cell">
    <button type="button" [attr.data-index]="i" [class]="makeItemClasses(i, pane)" [disabled]="isDisabled(i, pane)">
      {{itemLabels[i] || (value | date:itemFormat)}}
    </button>
  </div>
</div>
`,
                styles: [`button{display:block;color:inherit}button:not([disabled]){cursor:pointer}button[disabled]{pointer-events:none}.skm-datepicker-pane{flex-shrink:0;width:100%;display:flex;flex-direction:column;overflow:hidden}.skm-datepicker-week{display:flex}.skm-datepicker-weekday{width:14.28571%}.skm-datepicker-content{flex:1 0 0;display:flex;flex-direction:column}.skm-datepicker-grid{flex:1 0 0;display:flex;flex-wrap:wrap;align-content:flex-start;pointer-events:none}.skm-datepicker-indent{height:16.66667%}.skm-datepicker-cell{display:flex}:host-context(.skm-datepicker-days-view) .skm-datepicker-cell{width:14.28571%;height:16.66667%}:host-context(.skm-datepicker-months-view) .skm-datepicker-cell{width:33.33333%;height:25%}:host-context(.skm-datepicker-years-view) .skm-datepicker-cell{width:20%;height:25%}.skm-datepicker-item{flex:1;pointer-events:auto}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
GridComponent.ctorParameters = () => [
    { type: SliderComponent, },
    { type: ViewComponent, },
    { type: ViewStrategy, },
];
GridComponent.propDecorators = {
    "pane": [{ type: Input },],
    "currentTimestamp": [{ type: Input },],
    "selectedTimestamp": [{ type: Input },],
    "minTimestamp": [{ type: Input },],
    "maxTimestamp": [{ type: Input },],
    "itemFormat": [{ type: Input },],
    "itemLabels": [{ type: Input },],
    "_hostClass": [{ type: HostBinding, args: ['class',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DaysStrategyDirective extends ViewStrategy {
    constructor() {
        super(...arguments);
        this.viewMode = ViewMode.Days;
        this.itemClass = 'skm-datepicker-day';
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    normalizeTimestamp(timestamp) {
        return timestamp;
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    makeInitPanesSeed(timestamp) {
        return startOfMonth(timestamp).valueOf();
    }
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    makePane(timestamp, add, baseOrder, weekStart) {
        const /** @type {?} */ date = new Date(timestamp);
        date.setMonth(add + date.getMonth());
        const /** @type {?} */ firstDay = date.getDay();
        date.setMonth(1 + date.getMonth());
        date.setDate(0);
        const /** @type {?} */ monthLength = date.getDate();
        const /** @type {?} */ values = [];
        for (let /** @type {?} */ i = 1; i <= monthLength; i++) {
            values.push(date.setDate(i));
        }
        return {
            order: baseOrder + add,
            values: values,
            indent: (firstDay - weekStart + 7) % 7 || 7,
        };
    }
}
DaysStrategyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[skmDaysStrategy]',
                providers: [
                    { provide: ViewStrategy, useExisting: DaysStrategyDirective },
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MonthsStrategyDirective extends ViewStrategy {
    constructor() {
        super(...arguments);
        this.viewMode = ViewMode.Months;
        this.itemClass = 'skm-datepicker-month';
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    normalizeTimestamp(timestamp) {
        return new Date(timestamp).setDate(1);
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    makeInitPanesSeed(timestamp) {
        return startOfYear(timestamp).valueOf();
    }
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    makePane(timestamp, add, baseOrder, weekStart) {
        const /** @type {?} */ date = new Date(timestamp);
        date.setFullYear(add + date.getFullYear());
        const /** @type {?} */ values = [];
        for (let /** @type {?} */ i = 0; i < 12; i++) {
            values.push(date.setMonth(i));
        }
        return {
            order: baseOrder + add,
            values: values,
        };
    }
}
MonthsStrategyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[skmMonthsStrategy]',
                providers: [
                    { provide: ViewStrategy, useExisting: MonthsStrategyDirective },
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class YearsStrategyDirective extends ViewStrategy {
    constructor() {
        super(...arguments);
        this.viewMode = ViewMode.Years;
        this.itemClass = 'skm-datepicker-year';
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    normalizeTimestamp(timestamp) {
        return new Date(timestamp).setMonth(0, 1);
    }
    /**
     * @param {?} timestamp
     * @return {?}
     */
    makeInitPanesSeed(timestamp) {
        const /** @type {?} */ date = new Date(timestamp);
        const /** @type {?} */ origin = date.getFullYear();
        const /** @type {?} */ adjusted = origin - (origin % 20);
        return startOfYear(date).setFullYear(adjusted);
    }
    /**
     * @param {?} timestamp
     * @param {?} add
     * @param {?} baseOrder
     * @param {?} weekStart
     * @return {?}
     */
    makePane(timestamp, add, baseOrder, weekStart) {
        const /** @type {?} */ date = new Date(timestamp);
        const /** @type {?} */ origin = add * 20 + date.getFullYear();
        const /** @type {?} */ values = [];
        for (let /** @type {?} */ i = 0; i < 20; i++) {
            values.push(date.setFullYear(origin + i));
        }
        return {
            order: baseOrder + add,
            values: values,
        };
    }
}
YearsStrategyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[skmYearsStrategy]',
                providers: [
                    { provide: ViewStrategy, useExisting: YearsStrategyDirective },
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DatepickerModule {
}
DatepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    DatepickerComponent,
                    ViewComponent,
                    SliderComponent,
                    GridComponent,
                    DaysStrategyDirective,
                    MonthsStrategyDirective,
                    YearsStrategyDirective,
                ],
                exports: [
                    DatepickerComponent,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { DatepickerComponent, DatepickerModule, ViewMode, GridComponent as ɵf, slide as ɵe, SliderComponent as ɵd, zoom as ɵb, DaysStrategyDirective as ɵg, MonthsStrategyDirective as ɵh, ViewStrategy as ɵc, YearsStrategyDirective as ɵi, ViewComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2tpbW1lZC1kYXRlcGlja2VyLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3V0aWwvaGVscGVycy50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9kYXRlcGlja2VyL3ZpZXctbW9kZS50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi9kYXRlcGlja2VyL2RhdGVwaWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3NsaWRlci9zbGlkZS5hbmltYXRpb24udHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdXRpbC96b29tLmFuaW1hdGlvbi50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneS50cyIsIm5nOi8vc2tpbW1lZC1kYXRlcGlja2VyL2xpYi92aWV3L3ZpZXcuY29tcG9uZW50LnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy9tb250aHMtc3RyYXRlZ3kuZGlyZWN0aXZlLnRzIiwibmc6Ly9za2ltbWVkLWRhdGVwaWNrZXIvbGliL3ZpZXctc3RyYXRlZ2llcy95ZWFycy1zdHJhdGVneS5kaXJlY3RpdmUudHMiLCJuZzovL3NraW1tZWQtZGF0ZXBpY2tlci9saWIvZGF0ZXBpY2tlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcclxuICByZXR1cm4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZEYXkoZGF0ZTogRGF0ZSB8IG51bWJlcik6IERhdGUge1xyXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlIGFzIG51bWJlcik7XHJcbiAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZNb250aChkYXRlOiBEYXRlIHwgbnVtYmVyKTogRGF0ZSB7XHJcbiAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUgYXMgbnVtYmVyKTtcclxuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG4gIGQuc2V0RGF0ZSgxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZZZWFyKGRhdGU6IERhdGUgfCBudW1iZXIpOiBEYXRlIHtcclxuICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSBhcyBudW1iZXIpO1xyXG4gIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgZC5zZXRNb250aCgwLCAxKTtcclxuICByZXR1cm4gZDtcclxufVxyXG5cclxuLy8ga3Vkb3MgdG8gQG1pY2hlbDRuZ2VsMFxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWFzZU91dChwYW5SYXRpbzogbnVtYmVyKTogKHg6IG51bWJlcikgPT4gbnVtYmVyIHtcclxuICBjb25zdCBhID0gKHBhblJhdGlvIC0gMikgLyBwYW5SYXRpbyAqKiAzO1xyXG4gIGNvbnN0IGIgPSAoMyAtIDIgKiBwYW5SYXRpbykgLyBwYW5SYXRpbyAqKiAyO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gZWFzZU91dCh4OiBudW1iZXIpIHtcclxuICAgIHJldHVybiAoeCA+PSBwYW5SYXRpbykgPyAxIDogKChhICogeCArIGIpICogeCArIDEpICogeDtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcclxufVxyXG4iLCJleHBvcnQgZW51bSBWaWV3TW9kZSB7XHJcbiAgRGF5cyA9ICdkYXlzJyxcclxuICBNb250aHMgPSAnbW9udGhzJyxcclxuICBZZWFycyA9ICd5ZWFycycsXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbnB1dCxcclxuICBMT0NBTEVfSUQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uSW5pdCxcclxuICBPdXRwdXQsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRm9ybVN0eWxlLCBnZXRMb2NhbGVEYXlOYW1lcywgVHJhbnNsYXRpb25XaWR0aCwgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgaXNWYWxpZERhdGUsIG5vb3AsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4vdmlldy1tb2RlJztcclxuaW1wb3J0IHsgWm9vbURpcmVjdGlvbiB9IGZyb20gJy4uL3V0aWwvem9vbS5hbmltYXRpb24nO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZGF0ZXBpY2tlcicsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXJcIiBbbmdTd2l0Y2hdPVwidmlld1wiPlxyXG4gIDxza20tdmlld1xyXG4gICAgKm5nU3dpdGNoQ2FzZT1cIlZpZXdNb2RlLkRheXNcIlxyXG4gICAgc2ttRGF5c1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3XCJcclxuICAgIFt6b29tRGlyZWN0aW9uXT1cInpvb21EaXJlY3Rpb25cIlxyXG4gICAgW2luaXRpYWxUaW1lc3RhbXBdPVwiaW5pdGlhbFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2N1cnJlbnRUaW1lc3RhbXBdPVwiY3VycmVudFRpbWVzdGFtcFwiXHJcbiAgICBbc2VsZWN0ZWRUaW1lc3RhbXBdPVwic2VsZWN0ZWRUaW1lc3RhbXBcIlxyXG4gICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgW21heFRpbWVzdGFtcF09XCJtYXhUaW1lc3RhbXBcIlxyXG5cclxuICAgIFtkZXNlbGVjdEVuYWJsZWRdPVwiZGVzZWxlY3RFbmFibGVkXCJcclxuXHJcbiAgICBbaGVhZGluZ0Zvcm1hdF09XCJoZWFkaW5nRm9ybWF0XCJcclxuICAgIFt3ZWVrU3RhcnRdPVwid2Vla1N0YXJ0XCJcclxuICAgIFt3ZWVrRGF5TGFiZWxzXT1cIndlZWtEYXlMYWJlbHNcIlxyXG4gICAgW2l0ZW1Gb3JtYXRdPVwiZGF5Rm9ybWF0XCJcclxuICAgIFtpdGVtTGFiZWxzXT1cImRheUxhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5Nb250aHMsICdvdXQnKVwiXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzZWxlY3REYXkoJGV2ZW50KVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuTW9udGhzXCJcclxuICAgIHNrbU1vbnRoc1N0cmF0ZWd5XHJcbiAgICBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXZpZXcgc2ttLWRhdGVwaWNrZXItbW9udGhzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJtb250aEZvcm1hdFwiXHJcbiAgICBbaXRlbUxhYmVsc109XCJtb250aExhYmVsc1wiXHJcblxyXG4gICAgKGhlYWRlckNsaWNrKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5ZZWFycywgJ291dCcpXCJcclxuICAgIChpdGVtQ2hhbmdlKT1cInN3aXRjaFZpZXcoJGV2ZW50LCBWaWV3TW9kZS5EYXlzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbiAgPHNrbS12aWV3XHJcbiAgICAqbmdTd2l0Y2hDYXNlPVwiVmlld01vZGUuWWVhcnNcIlxyXG4gICAgc2ttWWVhcnNTdHJhdGVneVxyXG4gICAgY2xhc3M9XCJza20tZGF0ZXBpY2tlci12aWV3IHNrbS1kYXRlcGlja2VyLXllYXJzLXZpZXdcIlxyXG4gICAgW3pvb21EaXJlY3Rpb25dPVwiem9vbURpcmVjdGlvblwiXHJcbiAgICBbaW5pdGlhbFRpbWVzdGFtcF09XCJpbml0aWFsVGltZXN0YW1wXCJcclxuXHJcbiAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgIFtzZWxlY3RlZFRpbWVzdGFtcF09XCJzZWxlY3RlZFRpbWVzdGFtcFwiXHJcbiAgICBbbWluVGltZXN0YW1wXT1cIm1pblRpbWVzdGFtcFwiXHJcbiAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcblxyXG4gICAgW2hlYWRpbmdGb3JtYXRdPVwieWVhckZvcm1hdFwiXHJcbiAgICBbaXRlbUZvcm1hdF09XCJ5ZWFyRm9ybWF0XCJcclxuXHJcbiAgICAoaXRlbUNoYW5nZSk9XCJzd2l0Y2hWaWV3KCRldmVudCwgVmlld01vZGUuTW9udGhzLCAnaW4nKVwiXHJcbiAgPjwvc2ttLXZpZXc+XHJcbjwvZGl2PlxyXG5gLFxyXG4gIHN0eWxlczogW2Auc2ttLWRhdGVwaWNrZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci12aWV3e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX1gLCBgYnV0dG9ue2Rpc3BsYXk6YmxvY2s7Y29sb3I6aW5oZXJpdH1idXR0b246bm90KFtkaXNhYmxlZF0pe2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF17cG9pbnRlci1ldmVudHM6bm9uZX0uc2ttLWRhdGVwaWNrZXItcGFuZXtmbGV4LXNocmluazowO3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtvdmVyZmxvdzpoaWRkZW59LnNrbS1kYXRlcGlja2VyLXdlZWt7ZGlzcGxheTpmbGV4fS5za20tZGF0ZXBpY2tlci13ZWVrZGF5e3dpZHRoOjE0LjI4NTcxJX0uc2ttLWRhdGVwaWNrZXItY29udGVudHtmbGV4OjEgMCAwO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LnNrbS1kYXRlcGlja2VyLWdyaWR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXA7YWxpZ24tY29udGVudDpmbGV4LXN0YXJ0O3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLWluZGVudHtoZWlnaHQ6MTYuNjY2NjclfS5za20tZGF0ZXBpY2tlci1jZWxse2Rpc3BsYXk6ZmxleH06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1kYXlzLXZpZXcpIC5za20tZGF0ZXBpY2tlci1jZWxse3dpZHRoOjE0LjI4NTcxJTtoZWlnaHQ6MTYuNjY2NjclfTpob3N0LWNvbnRleHQoLnNrbS1kYXRlcGlja2VyLW1vbnRocy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDozMy4zMzMzMyU7aGVpZ2h0OjI1JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci15ZWFycy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoyMCU7aGVpZ2h0OjI1JX0uc2ttLWRhdGVwaWNrZXItaXRlbXtmbGV4OjE7cG9pbnRlci1ldmVudHM6YXV0b31gXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IERhdGVwaWNrZXJDb21wb25lbnQsIG11bHRpOiB0cnVlfSxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMsIE9uSW5pdCB7XHJcbiAgQElucHV0KCkgc2V0IGRhdGUoZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBpZiAoZGlydHlEYXRlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0ZSA9IHN0YXJ0T2ZEYXkoZGlydHlEYXRlKTtcclxuICAgIGlmIChkYXRlLmdldFRpbWUoKSAhPT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICB0aGlzLnNlbGVjdGVkVGltZXN0YW1wID0gaXNWYWxpZERhdGUoZGF0ZSkgPyBkYXRlLmdldFRpbWUoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlbGVjdGVkVGltZXN0YW1wICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFRpbWVzdGFtcCA9IHRoaXMuc2VsZWN0ZWRUaW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gVmlld01vZGUuRGF5cztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQE91dHB1dCgpIGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XHJcblxyXG4gIEBJbnB1dCgpIHNldCBtaW4oZGlydHlEYXRlOiBEYXRlIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBkYXRlID0gc3RhcnRPZkRheShkaXJ0eURhdGUpO1xyXG4gICAgdGhpcy5taW5UaW1lc3RhbXAgPSBpc1ZhbGlkRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgQElucHV0KCkgc2V0IG1heChkaXJ0eURhdGU6IERhdGUgfCBudW1iZXIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZSk7XHJcbiAgICB0aGlzLm1heFRpbWVzdGFtcCA9IGlzVmFsaWREYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGRheUZvcm1hdCA9ICdkJztcclxuICBASW5wdXQoKSBtb250aEZvcm1hdCA9ICdNTU0nO1xyXG4gIEBJbnB1dCgpIHllYXJGb3JtYXQgPSAneSc7XHJcbiAgQElucHV0KCkgaGVhZGluZ0Zvcm1hdCA9ICdNTU1NIHknO1xyXG4gIEBJbnB1dCgpIHdlZWtTdGFydCA9IFdlZWtEYXkuTW9uZGF5O1xyXG5cclxuICBASW5wdXQoKSBkYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIHdlZWtEYXlMYWJlbHM6IHN0cmluZ1tdO1xyXG4gIEBJbnB1dCgpIG1vbnRoTGFiZWxzOiBzdHJpbmdbXTtcclxuXHJcbiAgQElucHV0KCkgdmlldyA9IFZpZXdNb2RlLkRheXM7XHJcblxyXG4gIGluaXRpYWxUaW1lc3RhbXA6IG51bWJlcjtcclxuICBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwcml2YXRlIG9uQ2hhbmdlOiAoZGF0ZTogRGF0ZSkgPT4gdm9pZCA9IG5vb3A7XHJcbiAgcHJpdmF0ZSBvblRvdWNoZWQ6ICgpID0+IHZvaWQgPSBub29wO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgbG9jYWxlOiBzdHJpbmcpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnd2Vla0RheUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLndlZWtEYXlMYWJlbHMgPSB0aGlzLndlZWtEYXlMYWJlbHMgfHwgZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50VGltZXN0YW1wID0gc3RhcnRPZkRheShuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wIHx8IHRoaXMuY3VycmVudFRpbWVzdGFtcDtcclxuICAgIHRoaXMud2Vla0RheUxhYmVscyA9IHRoaXMud2Vla0RheUxhYmVscyB8fCBnZXRMb2NhbGVEYXlOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLlN0YW5kYWxvbmUsIFRyYW5zbGF0aW9uV2lkdGguQWJicmV2aWF0ZWQpO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0RGF5KHRpbWVzdGFtcDogbnVtYmVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZyh0aW1lc3RhbXApO1xyXG4gICAgdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgIGNvbnN0IGRhdGUgPSAodHlwZW9mIHRpbWVzdGFtcCAhPT0gJ3VuZGVmaW5lZCcpID8gbmV3IERhdGUodGltZXN0YW1wKSA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XHJcbiAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKTtcclxuICB9XHJcblxyXG4gIHN3aXRjaFZpZXcodGltZXN0YW1wOiBudW1iZXIsIHZpZXc6IFZpZXdNb2RlLCBkaXJlY3Rpb246IFpvb21EaXJlY3Rpb24pIHtcclxuICAgIHRoaXMuem9vbURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmluaXRpYWxUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGltcGxlbWVudGF0aW9uXHJcblxyXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuZGF0ZSA9IG9iajtcclxuICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgfVxyXG5cclxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gIH1cclxuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAvLyBUT0RPIGltcGxlbWVudFxyXG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUodGltaW5nOiBudW1iZXIgfCBzdHJpbmcgPSAxNTApOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEge1xyXG4gIHJldHVybiB0cmlnZ2VyKCdzbGlkZScsIFtcclxuICAgIHN0YXRlKCdwYW5uaW5nJywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKHt7eH19JSknLFxyXG4gICAgfSksIHtwYXJhbXM6IHt4OiAwfX0pLFxyXG4gICAgdHJhbnNpdGlvbignKiA9PiAxJywgYW5pbWF0ZSh0aW1pbmcsIHN0eWxlKHtcclxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLFxyXG4gICAgfSkpKSxcclxuICAgIHRyYW5zaXRpb24oJyogPT4gLTEnLCBhbmltYXRlKHRpbWluZywgc3R5bGUoe1xyXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKDEwMCUpJyxcclxuICAgIH0pKSksXHJcbiAgICB0cmFuc2l0aW9uKCdwYW5uaW5nID0+IGlkbGUnLCBhbmltYXRlKHRpbWluZykpLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgTmdab25lLFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3V0cHV0LFxyXG4gIFNpbXBsZUNoYW5nZXMsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGNyZWF0ZUVhc2VPdXQgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBzbGlkZSB9IGZyb20gJy4vc2xpZGUuYW5pbWF0aW9uJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmRlY2xhcmUgY2xhc3MgSGFtbWVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gIGNvbnN0cnVjdG9yKHRhcmdldDogRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblRyaWdnZXIge1xyXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgcGFyYW1zOiB7IFtwOiBzdHJpbmddOiBhbnkgfTtcclxufVxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tc2xpZGVyJyxcclxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1zbGlkZXJcIiBbQHNsaWRlXT1cInNsaWRlVHJpZ2dlclwiIChAc2xpZGUuZG9uZSk9XCJkb25lKCRldmVudClcIj5cclxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbjwvZGl2PlxyXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24gc2ttLXByZXZcIiAoY2xpY2spPVwic2xpZGUoLTEpXCIgW2Rpc2FibGVkXT1cInByZXZEaXNhYmxlZFwiPiZsc2FxdW87PC9idXR0b24+XHJcbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2ttLWRhdGVwaWNrZXItcGFnaW5hdGlvbiBza20tbmV4dFwiIChjbGljayk9XCJzbGlkZSgxKVwiIFtkaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIj4mcnNhcXVvOzwvYnV0dG9uPlxyXG5gLFxyXG4gIHN0eWxlczogW2A6aG9zdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlfS5za20tZGF0ZXBpY2tlci1zbGlkZXJ7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTEwMCU7aGVpZ2h0OjEwMCV9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb257cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LnNrbS1kYXRlcGlja2VyLXBhZ2luYXRpb24uc2ttLXByZXZ7bGVmdDowfS5za20tZGF0ZXBpY2tlci1wYWdpbmF0aW9uLnNrbS1uZXh0e3JpZ2h0OjB9YCwgYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3NsaWRlKCldLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xyXG4gIEBJbnB1dCgpIHByZXZEaXNhYmxlZCA9IGZhbHNlO1xyXG4gIEBJbnB1dCgpIG5leHREaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICBAT3V0cHV0KCkgc2xpZGVEb25lID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XHJcbiAgbm90UGFubmluZyA9IHRydWU7XHJcblxyXG4gIHNsaWRlVHJpZ2dlcjogQW5pbWF0aW9uVHJpZ2dlcjtcclxuXHJcbiAgcHJpdmF0ZSB3cmFwcGVyV2lkdGggPSAxO1xyXG4gIHByaXZhdGUgcGFuT2Zmc2V0ID0gMDtcclxuICBwcml2YXRlIGxhc3REb25lRXZlbnRUb1N0YXRlOiBzdHJpbmcgfCBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgbmdVbnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdCgpO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZWFzZU91dCA9IGNyZWF0ZUVhc2VPdXQoMS4zKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHtcclxuICAgIHRoaXMuY2QuZGV0YWNoKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgY29uc3QgaG9zdCA9IHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50O1xyXG4gICAgICBmcm9tRXZlbnQoaG9zdCwgJ21vdXNlZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFByZXNzKCkpO1xyXG5cclxuICAgICAgaWYgKCdIYW1tZXInIGluIHdpbmRvdykge1xyXG4gICAgICAgIGNvbnN0IGhhbW1lciA9IG5ldyBIYW1tZXIoaG9zdCk7XHJcblxyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdwYW5zdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdGFydFBhbigpKTtcclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAncGFubW92ZScpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoZSA9PiB0aGlzLnBhbihlKSk7XHJcbiAgICAgICAgZnJvbUV2ZW50KGhhbW1lciwgJ3BhbmVuZCBwYW5jYW5jZWwnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuZW5kUGFuKCkpO1xyXG5cclxuICAgICAgICBmcm9tRXZlbnQoaGFtbWVyLCAnc3dpcGVyaWdodCcpLnBpcGUodGFrZVVudGlsKHRoaXMubmdVbnN1YnNjcmliZSQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zd2lwZSgtMSkpO1xyXG4gICAgICAgIGZyb21FdmVudChoYW1tZXIsICdzd2lwZWxlZnQnKS5waXBlKHRha2VVbnRpbCh0aGlzLm5nVW5zdWJzY3JpYmUkKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3dpcGUoMSkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgdGhpcy5uZ1Vuc3Vic2NyaWJlJC5uZXh0KCk7XHJcbiAgICB0aGlzLm5nVW5zdWJzY3JpYmUkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBkb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09IHRoaXMubGFzdERvbmVFdmVudFRvU3RhdGUpIHtcclxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjQwODRcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sYXN0RG9uZUV2ZW50VG9TdGF0ZSA9IGV2ZW50LnRvU3RhdGU7XHJcbiAgICBpZiAodHlwZW9mIGV2ZW50LnRvU3RhdGUgYXMgc3RyaW5nIHwgbnVtYmVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICB0aGlzLnNsaWRlRG9uZS5lbWl0KGV2ZW50LnRvU3RhdGUgYXMgYW55KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNsaWRlKGRpcmVjdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcihkaXJlY3Rpb24gYXMgLTEgfCAxKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0UHJlc3MoKTogdm9pZCB7XHJcbiAgICB0aGlzLm5vdFBhbm5pbmcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydFBhbigpOiB2b2lkIHtcclxuICAgIHRoaXMubm90UGFubmluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFuKGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSAoZXZlbnQuZGVsdGFYID4gMCAmJiB0aGlzLnByZXZEaXNhYmxlZCB8fCBldmVudC5kZWx0YVggPCAwICYmIHRoaXMubmV4dERpc2FibGVkKSA/IDAuMSA6IDE7XHJcbiAgICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhldmVudC5kZWx0YVggLyB0aGlzLndyYXBwZXJXaWR0aCk7XHJcbiAgICB0aGlzLnBhbk9mZnNldCA9IE1hdGguc2lnbihldmVudC5kZWx0YVgpICogdGhpcy5lYXNlT3V0KGFic09mZnNldCk7XHJcbiAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigncGFubmluZycsIHRoaXMucGFuT2Zmc2V0ICogbXVsdGlwbGllcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGVuZFBhbigpOiB2b2lkIHtcclxuICAgIGlmIChNYXRoLmFicyh0aGlzLnBhbk9mZnNldCkgPiAwLjUpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoLU1hdGguc2lnbih0aGlzLnBhbk9mZnNldCkgYXMgLTEgfCAxKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zbGlkZVRyaWdnZXIudmFsdWUgPT09ICdwYW5uaW5nJykge1xyXG4gICAgICB0aGlzLmNoYW5nZVNsaWRlVHJpZ2dlcigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzd2lwZShkaXJlY3Rpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jaGFuZ2VTbGlkZVRyaWdnZXIoZGlyZWN0aW9uIGFzIC0xIHwgMSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoYW5nZVNsaWRlVHJpZ2dlcih2YWx1ZTogJ3Bhbm5pbmcnIHwgJ2lkbGUnIHwgLTEgfCAxID0gJ2lkbGUnLCBvZmZzZXQgPSAwKTogdm9pZCB7XHJcbiAgICB0aGlzLnNsaWRlVHJpZ2dlciA9IHtcclxuICAgICAgdmFsdWU6ICh2YWx1ZSA9PT0gLTEgJiYgdGhpcy5wcmV2RGlzYWJsZWQgfHwgdmFsdWUgPT09IDEgJiYgdGhpcy5uZXh0RGlzYWJsZWQpID8gJ2lkbGUnIDogdmFsdWUsXHJcbiAgICAgIHBhcmFtczoge3g6IG9mZnNldCAqIDEwMH0sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcblxyXG5leHBvcnQgdHlwZSBab29tRGlyZWN0aW9uID0gJ2luJyB8ICdvdXQnO1xyXG5cclxuY29uc3QgYmlnZ2VyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMC44KScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5jb25zdCBzbWFsbGVyU3R5bGUgPSBzdHlsZSh7XHJcbiAgdHJhbnNmb3JtOiAnc2NhbGUoMS4zKScsXHJcbiAgb3BhY2l0eTogMCxcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gem9vbSh0aW1pbmc6IG51bWJlciB8IHN0cmluZyA9IDE3NSk6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSB7XHJcbiAgcmV0dXJuIHRyaWdnZXIoJ3pvb20nLCBbXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IGluJywgW1xyXG4gICAgICBiaWdnZXJTdHlsZSxcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IG91dCcsIFtcclxuICAgICAgc21hbGxlclN0eWxlLFxyXG4gICAgICBhbmltYXRlKHRpbWluZyksXHJcbiAgICBdKSxcclxuICAgIHRyYW5zaXRpb24oJ2luID0+IHZvaWQnLCBbXHJcbiAgICAgIGFuaW1hdGUodGltaW5nLCBzbWFsbGVyU3R5bGUpLFxyXG4gICAgXSksXHJcbiAgICB0cmFuc2l0aW9uKCdvdXQgPT4gdm9pZCcsIFtcclxuICAgICAgYW5pbWF0ZSh0aW1pbmcsIGJpZ2dlclN0eWxlKSxcclxuICAgIF0pLFxyXG4gIF0pO1xyXG59XHJcbiIsImltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZpZXdTdHJhdGVneSB7XHJcbiAgYWJzdHJhY3QgcmVhZG9ubHkgdmlld01vZGU6IFZpZXdNb2RlO1xyXG4gIGFic3RyYWN0IHJlYWRvbmx5IGl0ZW1DbGFzczogc3RyaW5nO1xyXG5cclxuICBhYnN0cmFjdCBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gIGFic3RyYWN0IG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICBhYnN0cmFjdCBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lO1xyXG59XHJcbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyB6b29tLCBab29tRGlyZWN0aW9uIH0gZnJvbSAnLi4vdXRpbC96b29tLmFuaW1hdGlvbic7XHJcbmltcG9ydCB7IFZpZXdNb2RlIH0gZnJvbSAnLi4vZGF0ZXBpY2tlci92aWV3LW1vZGUnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuLi92aWV3LXN0cmF0ZWdpZXMvdmlldy1zdHJhdGVneSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3NrbS12aWV3JyxcclxuICB0ZW1wbGF0ZTogYDxza20tc2xpZGVyIFtwcmV2RGlzYWJsZWRdPVwicHJldkRpc2FibGVkXCIgW25leHREaXNhYmxlZF09XCJuZXh0RGlzYWJsZWRcIiAoc2xpZGVEb25lKT1cInN3aXRjaFBhbmVzKCRldmVudClcIiAjc2xpZGVyPlxyXG4gIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1wYW5lXCIgKm5nRm9yPVwibGV0IHBhbmUgb2YgcGFuZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXhcIiBbc3R5bGUub3JkZXJdPVwicGFuZS5vcmRlclwiPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJza20tZGF0ZXBpY2tlci1oZWFkZXJcIlxyXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xpY2tIZWFkZXIoc2xpZGVyLm5vdFBhbm5pbmcpXCIgW2Rpc2FibGVkXT1cInZpZXdTdHJhdGVneS52aWV3TW9kZSA9PT0gVmlld01vZGUuWWVhcnNcIj5cclxuICAgICAge3twYW5lLnZhbHVlc1swXSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ2aWV3U3RyYXRlZ3kudmlld01vZGUgPT09IFZpZXdNb2RlLlllYXJzXCI+XHJcbiAgICAgICAgJm5kYXNoOyB7e3BhbmUudmFsdWVzWzE5XSB8IGRhdGU6aGVhZGluZ0Zvcm1hdH19XHJcbiAgICAgIDwvbmctY29udGFpbmVyPlxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla1wiICpuZ0lmPVwidmlld1N0cmF0ZWd5LnZpZXdNb2RlID09PSBWaWV3TW9kZS5EYXlzXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJza20tZGF0ZXBpY2tlci13ZWVrZGF5XCIgKm5nRm9yPVwibGV0IGxhYmVsIG9mIHdlZWtEYXlMYWJlbHMgfCBzbGljZTp3ZWVrU3RhcnQ6N1wiPnt7bGFiZWx9fTwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItd2Vla2RheVwiICpuZ0Zvcj1cImxldCBsYWJlbCBvZiB3ZWVrRGF5TGFiZWxzIHwgc2xpY2U6MDp3ZWVrU3RhcnRcIj57e2xhYmVsfX08L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPHNrbS1ncmlkXHJcbiAgICAgIFtwYW5lXT1cInBhbmVcIlxyXG4gICAgICBbY3VycmVudFRpbWVzdGFtcF09XCJjdXJyZW50VGltZXN0YW1wXCJcclxuICAgICAgW3NlbGVjdGVkVGltZXN0YW1wXT1cInNlbGVjdGVkVGltZXN0YW1wXCJcclxuICAgICAgW21pblRpbWVzdGFtcF09XCJtaW5UaW1lc3RhbXBcIlxyXG4gICAgICBbbWF4VGltZXN0YW1wXT1cIm1heFRpbWVzdGFtcFwiXHJcbiAgICAgIFtpdGVtRm9ybWF0XT1cIml0ZW1Gb3JtYXRcIlxyXG4gICAgICBbaXRlbUxhYmVsc109XCJpdGVtTGFiZWxzXCJcclxuICAgID48L3NrbS1ncmlkPlxyXG4gIDwvZGl2PlxyXG48L3NrbS1zbGlkZXI+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgYW5pbWF0aW9uczogW3pvb20oKV0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ0B6b29tJykgem9vbURpcmVjdGlvbjogWm9vbURpcmVjdGlvbjtcclxuICBASW5wdXQoKSBpbml0aWFsVGltZXN0YW1wOiBudW1iZXI7XHJcblxyXG4gIEBJbnB1dCgpIGN1cnJlbnRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBzZWxlY3RlZFRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1pblRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIEBJbnB1dCgpIG1heFRpbWVzdGFtcDogbnVtYmVyO1xyXG5cclxuICBASW5wdXQoKSBkZXNlbGVjdEVuYWJsZWQ6IGJvb2xlYW47XHJcblxyXG4gIEBJbnB1dCgpIGhlYWRpbmdGb3JtYXQ6IHN0cmluZztcclxuICBASW5wdXQoKSB3ZWVrU3RhcnQ6IFdlZWtEYXk7XHJcbiAgQElucHV0KCkgd2Vla0RheUxhYmVsczogc3RyaW5nW107XHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdO1xyXG5cclxuICBAT3V0cHV0KCkgcmVhZG9ubHkgaXRlbUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG4gIEBPdXRwdXQoKSByZWFkb25seSBoZWFkZXJDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICByZWFkb25seSBWaWV3TW9kZSA9IFZpZXdNb2RlO1xyXG5cclxuICBwYW5lczogQXJyYXk8UGFuZT47XHJcbiAgcHJldkRpc2FibGVkID0gZmFsc2U7XHJcbiAgbmV4dERpc2FibGVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSB2aXNpYmxlUGFuZUluZGV4OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSByZWd1bGFyVGltZXN0YW1wRmllbGRzID0gWydjdXJyZW50VGltZXN0YW1wJywgJ3NlbGVjdGVkVGltZXN0YW1wJywgJ21pblRpbWVzdGFtcCcsICdtYXhUaW1lc3RhbXAnXTtcclxuXHJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnZpZXdTdHJhdGVneS52aWV3TW9kZSAhPT0gVmlld01vZGUuRGF5cykge1xyXG4gICAgICB0aGlzLnJlZ3VsYXJUaW1lc3RhbXBGaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XHJcbiAgICAgICAgaWYgKGZpZWxkIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXNbZmllbGRdID0gdGhpc1tmaWVsZF0gPyB0aGlzLnZpZXdTdHJhdGVneS5ub3JtYWxpemVUaW1lc3RhbXAodGhpc1tmaWVsZF0pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ2luaXRpYWxUaW1lc3RhbXAnIGluIGNoYW5nZXMpIHtcclxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYWZ0ZXIgbm9ybWFsaXphdGlvbiBvZiBvdGhlciB0aW1lc3RhbXBzIGZvciBwcm9wZXIgYmVoYXZpb3Igb2YgbWluLW1heCByYW5nZVxyXG4gICAgICB0aGlzLmluaXRQYW5lcyh0aGlzLmluaXRpYWxUaW1lc3RhbXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG4gIGNsaWNrSGVhZGVyKG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIHRoaXMuaGVhZGVyQ2xpY2suZW1pdCh0aGlzLnBhbmVzW3RoaXMudmlzaWJsZVBhbmVJbmRleF0udmFsdWVzWzBdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNlbGVjdEl0ZW0oZXZlbnQ6IE1vdXNlRXZlbnQsIHBhbmU6IFBhbmUsIG5vdFBhbm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChub3RQYW5uaW5nKSB7XHJcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgICAgY29uc3QgaW5kZXggPSBidXR0b24uZGF0YXNldC5pbmRleDtcclxuICAgICAgaWYgKHRoaXMuZGVzZWxlY3RFbmFibGVkICYmIHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5zZWxlY3RlZFRpbWVzdGFtcCkge1xyXG4gICAgICAgIHRoaXMuaXRlbUNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pdGVtQ2hhbmdlLmVtaXQocGFuZS52YWx1ZXNbaW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3dpdGNoUGFuZXMoZGlyZWN0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudmlzaWJsZVBhbmVJbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBpbmRleCA9ICgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4ICsgZGlyZWN0aW9uKSAlIDM7XHJcbiAgICBjb25zdCBwYW5lID0gdGhpcy5wYW5lc1tpbmRleF07XHJcbiAgICB0aGlzLnBhbmVzW2luZGV4XSA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VQYW5lKHBhbmUudmFsdWVzWzBdLCAzICogZGlyZWN0aW9uLCBwYW5lLm9yZGVyLCB0aGlzLndlZWtTdGFydCk7XHJcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkU3RhdHVzKCgzICsgdGhpcy52aXNpYmxlUGFuZUluZGV4IC0gMSkgJSAzLCAoMyArIHRoaXMudmlzaWJsZVBhbmVJbmRleCArIDEpICUgMyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRQYW5lcyh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc2VlZCA9IHRoaXMudmlld1N0cmF0ZWd5Lm1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcCk7XHJcbiAgICB0aGlzLnBhbmVzID0gWy0xLCAwLCAxXS5tYXAoaSA9PiB0aGlzLnZpZXdTdHJhdGVneS5tYWtlUGFuZShzZWVkLCBpLCAwLCB0aGlzLndlZWtTdGFydCkpO1xyXG4gICAgdGhpcy52aXNpYmxlUGFuZUluZGV4ID0gMTtcclxuICAgIHRoaXMudXBkYXRlRGlzYWJsZWRTdGF0dXMoMCwgMik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZURpc2FibGVkU3RhdHVzKHByZXZJbmRleDogbnVtYmVyLCBuZXh0SW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5wcmV2RGlzYWJsZWQgPSB0aGlzLnBhbmVzW3ByZXZJbmRleF0udmFsdWVzW3RoaXMucGFuZXNbcHJldkluZGV4XS52YWx1ZXMubGVuZ3RoIC0gMV0gPCB0aGlzLm1pblRpbWVzdGFtcDtcclxuICAgIHRoaXMubmV4dERpc2FibGVkID0gdGhpcy5wYW5lc1tuZXh0SW5kZXhdLnZhbHVlc1swXSA+IHRoaXMubWF4VGltZXN0YW1wO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuLi9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFZpZXdTdHJhdGVneSB9IGZyb20gJy4uL3ZpZXctc3RyYXRlZ2llcy92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld0NvbXBvbmVudCB9IGZyb20gJy4uL3ZpZXcvdmlldy5jb21wb25lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdza20tZ3JpZCcsXHJcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItZ3JpZFwiIChjbGljayk9XCJwYXJlbnRWaWV3LnNlbGVjdEl0ZW0oJGV2ZW50LCBwYW5lLCBzbGlkZXIubm90UGFubmluZylcIj5cclxuICA8ZGl2IGNsYXNzPVwic2ttLWRhdGVwaWNrZXItaW5kZW50XCIgW3N0eWxlLndpZHRoLiVdPVwiMTAwIC8gNyAqIHBhbmUuaW5kZW50XCI+PC9kaXY+XHJcbiAgPGRpdiAqbmdGb3I9XCJsZXQgdmFsdWUgb2YgcGFuZS52YWx1ZXM7IHRyYWNrQnk6IHRyYWNrSW5kZXg7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInNrbS1kYXRlcGlja2VyLWNlbGxcIj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIFthdHRyLmRhdGEtaW5kZXhdPVwiaVwiIFtjbGFzc109XCJtYWtlSXRlbUNsYXNzZXMoaSwgcGFuZSlcIiBbZGlzYWJsZWRdPVwiaXNEaXNhYmxlZChpLCBwYW5lKVwiPlxyXG4gICAgICB7e2l0ZW1MYWJlbHNbaV0gfHwgKHZhbHVlIHwgZGF0ZTppdGVtRm9ybWF0KX19XHJcbiAgICA8L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYGJ1dHRvbntkaXNwbGF5OmJsb2NrO2NvbG9yOmluaGVyaXR9YnV0dG9uOm5vdChbZGlzYWJsZWRdKXtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRde3BvaW50ZXItZXZlbnRzOm5vbmV9LnNrbS1kYXRlcGlja2VyLXBhbmV7ZmxleC1zaHJpbms6MDt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5za20tZGF0ZXBpY2tlci13ZWVre2Rpc3BsYXk6ZmxleH0uc2ttLWRhdGVwaWNrZXItd2Vla2RheXt3aWR0aDoxNC4yODU3MSV9LnNrbS1kYXRlcGlja2VyLWNvbnRlbnR7ZmxleDoxIDAgMDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5za20tZGF0ZXBpY2tlci1ncmlke2ZsZXg6MSAwIDA7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO2FsaWduLWNvbnRlbnQ6ZmxleC1zdGFydDtwb2ludGVyLWV2ZW50czpub25lfS5za20tZGF0ZXBpY2tlci1pbmRlbnR7aGVpZ2h0OjE2LjY2NjY3JX0uc2ttLWRhdGVwaWNrZXItY2VsbHtkaXNwbGF5OmZsZXh9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXItZGF5cy12aWV3KSAuc2ttLWRhdGVwaWNrZXItY2VsbHt3aWR0aDoxNC4yODU3MSU7aGVpZ2h0OjE2LjY2NjY3JX06aG9zdC1jb250ZXh0KC5za20tZGF0ZXBpY2tlci1tb250aHMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MzMuMzMzMzMlO2hlaWdodDoyNSV9Omhvc3QtY29udGV4dCguc2ttLWRhdGVwaWNrZXIteWVhcnMtdmlldykgLnNrbS1kYXRlcGlja2VyLWNlbGx7d2lkdGg6MjAlO2hlaWdodDoyNSV9LnNrbS1kYXRlcGlja2VyLWl0ZW17ZmxleDoxO3BvaW50ZXItZXZlbnRzOmF1dG99YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBHcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBASW5wdXQoKSBwYW5lOiBQYW5lO1xyXG5cclxuICBASW5wdXQoKSBjdXJyZW50VGltZXN0YW1wOiBudW1iZXI7XHJcbiAgQElucHV0KCkgc2VsZWN0ZWRUaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtaW5UaW1lc3RhbXA6IG51bWJlcjtcclxuICBASW5wdXQoKSBtYXhUaW1lc3RhbXA6IG51bWJlcjtcclxuXHJcbiAgQElucHV0KCkgaXRlbUZvcm1hdDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGl0ZW1MYWJlbHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MnKSByZWFkb25seSBfaG9zdENsYXNzID0gJ3NrbS1kYXRlcGlja2VyLWNvbnRlbnQnO1xyXG5cclxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBzbGlkZXI6IFNsaWRlckNvbXBvbmVudCxcclxuICAgICAgICAgICAgICByZWFkb25seSBwYXJlbnRWaWV3OiBWaWV3Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVhZG9ubHkgdmlld1N0cmF0ZWd5OiBWaWV3U3RyYXRlZ3kpIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmICgnaXRlbUxhYmVscycgaW4gY2hhbmdlcykge1xyXG4gICAgICB0aGlzLml0ZW1MYWJlbHMgPSB0aGlzLml0ZW1MYWJlbHMgfHwgW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtYWtlSXRlbUNsYXNzZXMoaW5kZXg6IG51bWJlciwgcGFuZTogUGFuZSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLnZpZXdTdHJhdGVneS5pdGVtQ2xhc3MsXHJcbiAgICAgICdza20tZGF0ZXBpY2tlci1pdGVtJyxcclxuICAgICAgKHBhbmUudmFsdWVzW2luZGV4XSA9PT0gdGhpcy5jdXJyZW50VGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1jdXJyZW50JyA6ICcnLFxyXG4gICAgICAocGFuZS52YWx1ZXNbaW5kZXhdID09PSB0aGlzLnNlbGVjdGVkVGltZXN0YW1wKSA/ICdza20tZGF0ZXBpY2tlci1zZWxlY3RlZCcgOiAnJyxcclxuICAgIF0uam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgaXNEaXNhYmxlZChpbmRleDogbnVtYmVyLCBwYW5lOiBQYW5lKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKHBhbmUudmFsdWVzW2luZGV4XSA8IHRoaXMubWluVGltZXN0YW1wKSB8fCAocGFuZS52YWx1ZXNbaW5kZXhdID4gdGhpcy5tYXhUaW1lc3RhbXApO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBpbmRleDtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4uL2RhdGVwaWNrZXIvdmlldy1tb2RlJztcclxuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uL3BhbmUnO1xyXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgc3RhcnRPZk1vbnRoIH0gZnJvbSAnLi4vdXRpbC9oZWxwZXJzJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3NrbURheXNTdHJhdGVneV0nLFxyXG4gIHByb3ZpZGVyczogW1xyXG4gICAge3Byb3ZpZGU6IFZpZXdTdHJhdGVneSwgdXNlRXhpc3Rpbmc6IERheXNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIERheXNTdHJhdGVneURpcmVjdGl2ZSBleHRlbmRzIFZpZXdTdHJhdGVneSB7XHJcbiAgcmVhZG9ubHkgdmlld01vZGUgPSBWaWV3TW9kZS5EYXlzO1xyXG4gIHJlYWRvbmx5IGl0ZW1DbGFzcyA9ICdza20tZGF0ZXBpY2tlci1kYXknO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRpbWVzdGFtcDtcclxuICB9XHJcblxyXG4gIG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzdGFydE9mTW9udGgodGltZXN0YW1wKS52YWx1ZU9mKCk7XHJcbiAgfVxyXG5cclxuICBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgZGF0ZS5zZXRNb250aChhZGQgKyBkYXRlLmdldE1vbnRoKCkpO1xyXG4gICAgY29uc3QgZmlyc3REYXkgPSBkYXRlLmdldERheSgpO1xyXG5cclxuICAgIGRhdGUuc2V0TW9udGgoMSArIGRhdGUuZ2V0TW9udGgoKSk7XHJcbiAgICBkYXRlLnNldERhdGUoMCk7XHJcbiAgICBjb25zdCBtb250aExlbmd0aCA9IGRhdGUuZ2V0RGF0ZSgpO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbW9udGhMZW5ndGg7IGkrKykge1xyXG4gICAgICB2YWx1ZXMucHVzaChkYXRlLnNldERhdGUoaSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9yZGVyOiBiYXNlT3JkZXIgKyBhZGQsXHJcbiAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICBpbmRlbnQ6IChmaXJzdERheSAtIHdlZWtTdGFydCArIDcpICUgNyB8fCA3LCAvLyBEZWZhdWx0aW5nIHRvIGZ1bGwgd2VlayBtYWtlcyBmb3IgbW9yZSBhIGJhbGFuY2VkIGNlbGxzIGxheW91dFxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vcGFuZSc7XHJcbmltcG9ydCB7IHN0YXJ0T2ZZZWFyIH0gZnJvbSAnLi4vdXRpbC9oZWxwZXJzJztcclxuaW1wb3J0IHsgVmlld1N0cmF0ZWd5IH0gZnJvbSAnLi92aWV3LXN0cmF0ZWd5JztcclxuaW1wb3J0IHsgVmlld01vZGUgfSBmcm9tICcuLi9kYXRlcGlja2VyL3ZpZXctbW9kZSc7XHJcbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbc2ttTW9udGhzU3RyYXRlZ3ldJyxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtwcm92aWRlOiBWaWV3U3RyYXRlZ3ksIHVzZUV4aXN0aW5nOiBNb250aHNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIE1vbnRoc1N0cmF0ZWd5RGlyZWN0aXZlIGV4dGVuZHMgVmlld1N0cmF0ZWd5IHtcclxuICByZWFkb25seSB2aWV3TW9kZSA9IFZpZXdNb2RlLk1vbnRocztcclxuICByZWFkb25seSBpdGVtQ2xhc3MgPSAnc2ttLWRhdGVwaWNrZXItbW9udGgnO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkuc2V0RGF0ZSgxKTtcclxuICB9XHJcblxyXG4gIG1ha2VJbml0UGFuZXNTZWVkKHRpbWVzdGFtcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBzdGFydE9mWWVhcih0aW1lc3RhbXApLnZhbHVlT2YoKTtcclxuICB9XHJcblxyXG4gIG1ha2VQYW5lKHRpbWVzdGFtcDogbnVtYmVyLCBhZGQ6IG51bWJlciwgYmFzZU9yZGVyOiBudW1iZXIsIHdlZWtTdGFydDogV2Vla0RheSk6IFBhbmUge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGFkZCArIGRhdGUuZ2V0RnVsbFllYXIoKSk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgdmFsdWVzLnB1c2goZGF0ZS5zZXRNb250aChpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JkZXI6IGJhc2VPcmRlciArIGFkZCxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBhbmUgfSBmcm9tICcuLi9wYW5lJztcclxuaW1wb3J0IHsgc3RhcnRPZlllYXIgfSBmcm9tICcuLi91dGlsL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBWaWV3U3RyYXRlZ3kgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBWaWV3TW9kZSB9IGZyb20gJy4uL2RhdGVwaWNrZXIvdmlldy1tb2RlJztcclxuaW1wb3J0IHsgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tza21ZZWFyc1N0cmF0ZWd5XScsXHJcbiAgcHJvdmlkZXJzOiBbXHJcbiAgICB7cHJvdmlkZTogVmlld1N0cmF0ZWd5LCB1c2VFeGlzdGluZzogWWVhcnNTdHJhdGVneURpcmVjdGl2ZX0sXHJcbiAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIFllYXJzU3RyYXRlZ3lEaXJlY3RpdmUgZXh0ZW5kcyBWaWV3U3RyYXRlZ3kge1xyXG4gIHJlYWRvbmx5IHZpZXdNb2RlID0gVmlld01vZGUuWWVhcnM7XHJcbiAgcmVhZG9ubHkgaXRlbUNsYXNzID0gJ3NrbS1kYXRlcGlja2VyLXllYXInO1xyXG5cclxuICBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCkuc2V0TW9udGgoMCwgMSk7XHJcbiAgfVxyXG5cclxuICBtYWtlSW5pdFBhbmVzU2VlZCh0aW1lc3RhbXA6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKTtcclxuICAgIGNvbnN0IG9yaWdpbiA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIGNvbnN0IGFkanVzdGVkID0gb3JpZ2luIC0gKG9yaWdpbiAlIDIwKTtcclxuICAgIHJldHVybiBzdGFydE9mWWVhcihkYXRlKS5zZXRGdWxsWWVhcihhZGp1c3RlZCk7XHJcbiAgfVxyXG5cclxuICBtYWtlUGFuZSh0aW1lc3RhbXA6IG51bWJlciwgYWRkOiBudW1iZXIsIGJhc2VPcmRlcjogbnVtYmVyLCB3ZWVrU3RhcnQ6IFdlZWtEYXkpOiBQYW5lIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG4gICAgY29uc3Qgb3JpZ2luID0gYWRkICogMjAgKyBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICAgICAgdmFsdWVzLnB1c2goZGF0ZS5zZXRGdWxsWWVhcihvcmlnaW4gKyBpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3JkZXI6IGJhc2VPcmRlciArIGFkZCxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgRGF0ZXBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFNsaWRlckNvbXBvbmVudCB9IGZyb20gJy4vc2xpZGVyL3NsaWRlci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi92aWV3L3ZpZXcuY29tcG9uZW50JztcclxuaW1wb3J0IHsgR3JpZENvbXBvbmVudCB9IGZyb20gJy4vZ3JpZC9ncmlkLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IERheXNTdHJhdGVneURpcmVjdGl2ZSB9IGZyb20gJy4vdmlldy1zdHJhdGVnaWVzL2RheXMtc3RyYXRlZ3kuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgTW9udGhzU3RyYXRlZ3lEaXJlY3RpdmUgfSBmcm9tICcuL3ZpZXctc3RyYXRlZ2llcy9tb250aHMtc3RyYXRlZ3kuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgWWVhcnNTdHJhdGVneURpcmVjdGl2ZSB9IGZyb20gJy4vdmlldy1zdHJhdGVnaWVzL3llYXJzLXN0cmF0ZWd5LmRpcmVjdGl2ZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZSxcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW1xyXG4gICAgRGF0ZXBpY2tlckNvbXBvbmVudCxcclxuICAgIFZpZXdDb21wb25lbnQsXHJcbiAgICBTbGlkZXJDb21wb25lbnQsXHJcbiAgICBHcmlkQ29tcG9uZW50LFxyXG4gICAgRGF5c1N0cmF0ZWd5RGlyZWN0aXZlLFxyXG4gICAgTW9udGhzU3RyYXRlZ3lEaXJlY3RpdmUsXHJcbiAgICBZZWFyc1N0cmF0ZWd5RGlyZWN0aXZlLFxyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgRGF0ZXBpY2tlckNvbXBvbmVudCxcclxuICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlck1vZHVsZSB7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFCQUE0QixJQUFVO0lBQ3BDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7Q0FDL0I7Ozs7O0FBRUQsb0JBQTJCLElBQW1CO0lBQzVDLHVCQUFNLENBQUMsR0FBRyxJQUFJLElBQUksbUJBQUMsSUFBYyxFQUFDLENBQUM7SUFDbkMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QixPQUFPLENBQUMsQ0FBQztDQUNWOzs7OztBQUVELHNCQUE2QixJQUFtQjtJQUM5Qyx1QkFBTSxDQUFDLEdBQUcsSUFBSSxJQUFJLG1CQUFDLElBQWMsRUFBQyxDQUFDO0lBQ25DLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNiLE9BQU8sQ0FBQyxDQUFDO0NBQ1Y7Ozs7O0FBRUQscUJBQTRCLElBQW1CO0lBQzdDLHVCQUFNLENBQUMsR0FBRyxJQUFJLElBQUksbUJBQUMsSUFBYyxFQUFDLENBQUM7SUFDbkMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqQixPQUFPLENBQUMsQ0FBQztDQUNWOzs7OztBQUdELHVCQUE4QixRQUFnQjtJQUM1Qyx1QkFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLFNBQUEsUUFB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